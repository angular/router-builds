{"version":3,"sources":["../../../../modules/@angular/router/src/config.ts"],"names":[],"mappings":"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","file":"config.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, Type} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * @whatItDoes Represents router configuration.\n *\n * @description\n * `Routes` is an array of route configurations. Each one has the following properties:\n *\n * - `path` is a string that uses the route matcher DSL.\n * - `pathMatch` is a string that specifies the matching strategy.\n * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.\n *   See {@link UrlMatcher} for more info.\n * - `component` is a component type.\n * - `redirectTo` is the url fragment which will replace the current matched segment.\n * - `outlet` is the name of the outlet the component should be placed into.\n * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See\n *   {@link CanActivate} for more info.\n * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See\n *   {@link CanActivateChild} for more info.\n * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See\n *   {@link CanDeactivate} for more info.\n * - `canLoad` is an array of DI tokens used to look up CanDeactivate handlers. See\n *   {@link CanLoad} for more info.\n * - `data` is additional data provided to the component via `ActivatedRoute`.\n * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more\n *   info.\n * - `children` is an array of child route definitions.\n * - `loadChildren` is a reference to lazy loaded child routes. See {@link LoadChildren} for more\n *   info.\n *\n * ### Simple Configuration\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/bob`, the router will create the team component with the user\n * component in it.\n *\n * ### Multiple Outlets\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to\n * the chat component. The chat component will be placed into the aux outlet.\n *\n * ### Wild Cards\n *\n * ```\n * [{\n *   path: '**',\n *   component: Sink\n * }]\n * ```\n *\n * Regardless of where you navigate to, the router will instantiate the sink component.\n *\n * ### Redirects\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to '/team/11/legacy/user/jim', the router will change the url to\n * '/team/11/user/jim', and then will instantiate the team component with the user component\n * in it.\n *\n * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the\n * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.\n *\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any url segments. Let's look at the following configuration:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11`, the router will instantiate the AllUsers component.\n *\n * Empty-path routes can have children.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with\n * the user component in it.\n *\n * An empty path route inherits its parent's params and data. This is because it cannot have its\n * own params, and, as a result, it often uses its parent's params and data as its own.\n *\n * ### Matching Strategy\n *\n * By default the router will look at what is left in the url, and check if it starts with\n * the specified path (e.g., `/team/11/user` starts with `team/:id`).\n *\n * We can change the matching strategy to make sure that the path covers the whole unconsumed url,\n * which is akin to `unconsumedUrl === path` or `$` regular expressions.\n *\n * This is particularly important when redirecting empty-path routes.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * Since an empty path is a prefix of any url, even when navigating to '/main', the router will\n * still apply the redirect.\n *\n * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to\n * '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * It is useful at times to have the ability to share parameters between sibling components.\n *\n * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\n * of them require some id parameter.\n *\n * One way to do that would be to have a bogus parent component, so both the siblings can get the id\n * parameter from it. This is not ideal. Instead, you can use a componentless route.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux\n * child components next to each other. In this example, the application component\n * has to have the primary and aux outlets defined.\n *\n * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into\n * the `params`, `data`, and `resolve` of the children. This is done because there is no component\n * that can inject the activated route of the componentless parent.\n *\n * This is especially useful when child components are defined as follows:\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * With this configuration in place, navigating to '/parent/10' will create the main child and aux\n * components.\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up our application load time by splitting it into multiple bundles, and\n * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of\n * providing the children property, you can provide the `loadChildren` property, as follows:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   loadChildren: 'team'\n * }]\n * ```\n *\n * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.\n * Then it will extract the set of routes defined in that NgModule, and will transparently add\n * those routes to the main configuration.\n *\n * @stable use Routes\n */\nexport type Routes = Route[];\n\n/**\n * @whatItDoes Represents the results of the URL matching.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @experimental\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[]; posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * @whatItDoes A function matching URLs\n *\n * @description\n *\n * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't\n * expressive enough.\n *\n * For instance, the following matcher matches html files.\n *\n * ```\n * function htmlFiles(url: UrlSegment[]) {\n *  return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * const routes = [{ matcher: htmlFiles, component: HtmlCmp }];\n * ```\n *\n * @experimental\n */\nexport type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) =>\n    UrlMatchResult;\n\n/**\n * @whatItDoes Represents the static data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes Represents the resolved data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes The type of `loadChildren`.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildrenCallback = () =>\n    Type<any>| NgModuleFactory<any>| Promise<Type<any>>| Observable<Type<any>>;\n\n/**\n * @whatItDoes The type of `loadChildren`.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildren = string | LoadChildrenCallback;\n\n/**\n * @whatItDoes The type of `queryParamsHandling`.\n * See {@link RouterLink} for more details.\n * @stable\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * See {@link Routes} for more details.\n * @stable\n */\nexport interface Route {\n  path?: string;\n  pathMatch?: string;\n  matcher?: UrlMatcher;\n  component?: Type<any>;\n  redirectTo?: string;\n  outlet?: string;\n  canActivate?: any[];\n  canActivateChild?: any[];\n  canDeactivate?: any[];\n  canLoad?: any[];\n  data?: Data;\n  resolve?: ResolveData;\n  children?: Routes;\n  loadChildren?: LoadChildren;\n}\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\nexport function validateConfig(config: Routes, parentPath: string = ''): void {\n  // forEach doesn't iterate undefined values\n  for (let /** @type {?} */ i = 0; i < config.length; i++) {\n    const /** @type {?} */ route: Route = config[i];\n    const /** @type {?} */ fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\nfunction validateNode(route: Route, fullPath: string): void {\n  if (!route) {\n    throw new Error(`\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n       \n      Example: \n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n  }\n  if (Array.isArray(route)) {\n    throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);\n  }\n  if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': a componentless route cannot have a named outlet set`);\n  }\n  if (route.redirectTo && route.children) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n  }\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n  }\n  if (route.children && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n  }\n  if (route.redirectTo && route.component) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`);\n  }\n  if (route.path && route.matcher) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n  }\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);\n  }\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n  }\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(`Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    const /** @type {?} */ exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`);\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n"]}