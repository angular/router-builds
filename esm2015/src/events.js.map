{"version":3,"file":"events.js","sourceRoot":"","sources":["../../../../packages/router/src/events.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './config';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n\n/**\n * @description\n *\n * Identifies the trigger of the navigation.\n *\n * * 'imperative'--triggered by `router.navigateByUrl` or `router.navigate`.\n * * 'popstate'--triggered by a popstate event\n * * 'hashchange'--triggered by a hashchange event\n *\n * @experimental\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\n\n/**\n * @description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @experimental\n */\nexport class RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      public id: number,\n      /** @docsNotRequired */\n      public url: string) {}\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\nexport class NavigationStart extends RouterEvent {\n  /**\n   * Identifies the trigger of the navigation.\n   *\n   * * 'imperative'--triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--triggered by a popstate event\n   * * 'hashchange'--triggered by a hashchange event\n   */\n  navigationTrigger?: 'imperative'|'popstate'|'hashchange';\n\n  /**\n   * This contains the navigation id that pushed the history record that the router navigates\n   * back to. This is not null only when the navigation is triggered by a popstate event.\n   *\n   * The router assigns a navigationId to every router transition/navigation. Even when the user\n   * clicks on the back button in the browser, a new navigation id will be created. So from\n   * the perspective of the router, the router never \"goes back\". By using the `restoredState`\n   * and its navigationId, you can implement behavior that differentiates between creating new\n   * states\n   * and popstate events. In the latter case you can restore some remembered state (e.g., scroll\n   * position).\n   */\n  restoredState?: {navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: 'imperative'|'popstate'|'hashchange' = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationStart(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\nexport class NavigationEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\nexport class NavigationCancel extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public reason: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationCancel(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\nexport class NavigationError extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\nexport class RoutesRecognized extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of the Guard phase of routing.\n *\n * @experimental\n */\nexport class GuardsCheckStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the end of the Guard phase of routing.\n *\n * @experimental\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * @experimental\n */\nexport class ResolveStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ResolveEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * @experimental\n */\nexport class RouteConfigLoadStart {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadStart(path: ${this.route.path})`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * @experimental\n */\nexport class RouteConfigLoadEnd {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadEnd(path: ${this.route.path})`; }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * @experimental\n */\nexport class ChildActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ChildActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * @experimental\n */\nexport class ActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents a router event, allowing you to track the lifecycle of the router.\n *\n * The sequence of router events is:\n *\n * - `NavigationStart`,\n * - `RouteConfigLoadStart`,\n * - `RouteConfigLoadEnd`,\n * - `RoutesRecognized`,\n * - `GuardsCheckStart`,\n * - `ChildActivationStart`,\n * - `ActivationStart`,\n * - `GuardsCheckEnd`,\n * - `ResolveStart`,\n * - `ResolveEnd`,\n * - `ActivationEnd`\n * - `ChildActivationEnd`\n * - `NavigationEnd`,\n * - `NavigationCancel`,\n * - `NavigationError`\n *\n *\n */\nexport type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart |\n    ChildActivationEnd | ActivationStart | ActivationEnd;\n"]}