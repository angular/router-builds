{"version":3,"file":"_router-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/shared.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/first_value_from.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/collection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/url_tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/create_url_tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/events.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/config.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/router_outlet_context.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/router_state.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/directives/router_outlet.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/components/empty_outlet.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/create_router_state.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/navigation_canceling_error.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/activate_routes.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/preactivation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/type_guards.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/prioritized_guard_value.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/abort_signal_to_observable.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/check_guards.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/apply_redirects.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/config_matching.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/recognize.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/apply_redirects_rxjs.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/recognize_rxjs.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/recognize.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/resolve_data.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/operators/switch_tap.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/page_title_strategy.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/router_config.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/router_config_loader.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/url_handling_strategy.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/utils/view_transition.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/navigation_transition.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/route_reuse_strategy.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/statemanager/state_manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/router/src/router.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Route, UrlMatchResult} from './models';\nimport type {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nexport const RouteTitleKey: unique symbol = /* @__PURE__ */ Symbol('RouteTitle');\n\n/**\n * A collection of matrix and query URL parameters.\n * @see {@link convertToParamMap}\n * @see {@link ParamMap}\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string | null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string | null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\nfunction matchParts(\n  routeParts: string[],\n  urlSegments: UrlSegment[],\n  posParams: {[key: string]: UrlSegment},\n): boolean {\n  for (let i = 0; i < routeParts.length; i++) {\n    const part = routeParts[i];\n    const segment = urlSegments[i];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nexport function defaultUrlMatcher(\n  segments: UrlSegment[],\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n): UrlMatchResult | null {\n  const parts = route.path!.split('/');\n  const wildcardIndex = parts.indexOf('**');\n  if (wildcardIndex === -1) {\n    // No wildcard, use original logic\n    if (parts.length > segments.length) {\n      // The actual URL is shorter than the config, no match\n      return null;\n    }\n\n    if (\n      route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)\n    ) {\n      // The config is longer than the actual URL but we are looking for a full match, return null\n      return null;\n    }\n\n    const posParams: {[key: string]: UrlSegment} = {};\n    const consumed = segments.slice(0, parts.length);\n    if (!matchParts(parts, consumed, posParams)) {\n      return null;\n    }\n    return {consumed, posParams};\n  }\n\n  // Path has a wildcard.\n  if (wildcardIndex !== parts.lastIndexOf('**')) {\n    // We do not support more than one wildcard segment in the path\n    return null;\n  }\n\n  const pre = parts.slice(0, wildcardIndex);\n  const post = parts.slice(wildcardIndex + 1);\n\n  if (pre.length + post.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n  if (\n    // If the wildcard is not at the end of the path, it must match at least one segment.\n    // e.g. `foo/**/bar` does not match `foo/bar`.\n    wildcardIndex > -1 &&\n    pre.length > 0 &&\n    post.length > 0 &&\n    pre.length + post.length === segments.length\n  ) {\n    return null;\n  }\n\n  if (\n    route.pathMatch === 'full' &&\n    (segmentGroup.hasChildren() || segments.length > pre.length + post.length)\n  ) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Match the segments before the wildcard\n  if (!matchParts(pre, segments.slice(0, pre.length), posParams)) {\n    return null;\n  }\n  // Match the segments after the wildcard\n  if (!matchParts(post, segments.slice(segments.length - post.length), posParams)) {\n    return null;\n  }\n\n  // TODO(atscott): put the wildcard segments into a _splat param.\n  // this would require a breaking change to the UrlMatchResult to allow UrlSegment[]\n  // since the splat could be multiple segments.\n\n  return {consumed: segments, posParams};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\nimport {first} from 'rxjs/operators';\n\n/** replacement for firstValueFrom in rxjs 7. We must support rxjs v6 so we cannot use it */\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    source.pipe(first()).subscribe({\n      next: (value) => resolve(value),\n      error: (err) => reject(err),\n    });\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵisPromise as isPromise} from '@angular/core';\nimport {from, isObservable, Observable, of} from 'rxjs';\nimport {firstValueFrom} from './first_value_from';\n\nexport function shallowEqualArrays(a: readonly any[], b: readonly any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(\n  a: {[key: string | symbol]: any},\n  b: {[key: string | symbol]: any},\n): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string | symbol;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nexport function getDataKeys(obj: Object): Array<string | symbol> {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(\n  a: string | readonly string[],\n  b: string | readonly string[],\n): boolean {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: readonly T[]): T | null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\nexport function wrapIntoObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n\nexport function wrapIntoPromise<T>(value: T | Promise<T> | Observable<T>): Promise<T> {\n  if (isObservable(value)) {\n    return firstValueFrom(value);\n  }\n  return Promise.resolve(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, shallowEqual} from './utils/collection';\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see {@link Router#isActive}\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact' | 'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact' | 'ignored';\n}\n\ntype ParamMatchOptions = 'exact' | 'subset' | 'ignored';\n\ntype PathCompareFn = (\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n) => boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n  container: UrlTree,\n  containee: UrlTree,\n  options: IsActiveMatchOptions,\n): boolean {\n  return (\n    pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n    paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n    !(options.fragment === 'exact' && container.fragment !== containee.fragment)\n  );\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return (\n    Object.keys(containee).length <= Object.keys(container).length &&\n    Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]))\n  );\n}\n\nfunction containsSegmentGroup(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  containeePaths: UrlSegment[],\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n      container.children[PRIMARY_OUTLET],\n      containee,\n      next,\n      matrixParams,\n    );\n  }\n}\n\nfunction matrixParamsMatch(\n  containerPaths: UrlSegment[],\n  containeePaths: UrlSegment[],\n  options: ParamMatchOptions,\n) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  constructor(\n    /** The root segment group of the URL tree */\n    public root: UrlSegmentGroup = new UrlSegmentGroup([], {}),\n    /** The query params of the URL */\n    public queryParams: Params = {},\n    /** The fragment of the URL */\n    public fragment: string | null = null,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT,\n          'The root `UrlSegmentGroup` should not contain `segments`. ' +\n            'Instead, these segments belong in the `children` so they can be associated with a named outlet.',\n        );\n      }\n    }\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup | null = null;\n\n  constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    public segments: UrlSegment[],\n    /** The list of children of this group */\n    public children: {[key: string]: UrlSegmentGroup},\n  ) {\n    Object.values(children).forEach((v) => (v.parent = this));\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  _parameterMap?: ParamMap;\n\n  constructor(\n    /** The path part of a URL segment */\n    public path: string,\n\n    /** The matrix parameters associated with a segment */\n    public parameters: {[name: string]: string},\n  ) {}\n\n  get parameterMap(): ParamMap {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n  segment: UrlSegmentGroup,\n  fn: (v: UrlSegmentGroup, k: string) => T[],\n): T[] {\n  let res: T[] = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => new DefaultUrlSerializer()})\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n      typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map((p) => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET]\n      ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n      : '';\n    const children: string[] = [];\n\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.entries(params)\n    .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n    .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] = Object.entries(params)\n    .map(([name, value]) => {\n      return Array.isArray(value)\n        ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n        : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n    .filter((s) => s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str: string): string {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string | null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n        RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Empty path url segment cannot have parameters: '${this.remaining}'.`,\n      );\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n          RuntimeErrorCode.UNPARSABLE_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`,\n        );\n      }\n\n      let outletName: string | undefined;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName ?? PRIMARY_OUTLET] =\n        Object.keys(children).length === 1 && children[PRIMARY_OUTLET]\n          ? children[PRIMARY_OUTLET]\n          : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`,\n      );\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup): UrlSegmentGroup {\n  return rootCandidate.segments.length > 0\n    ? new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate})\n    : rootCandidate;\n}\n\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren: Record<string, UrlSegmentGroup> = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (\n      childOutlet === PRIMARY_OUTLET &&\n      childCandidate.segments.length === 0 &&\n      childCandidate.hasChildren()\n    ) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {\n  createRoot,\n  DefaultUrlSerializer,\n  squashSegmentGroup,\n  UrlSegment,\n  UrlSegmentGroup,\n  UrlSerializer,\n  UrlTree,\n} from './url_tree';\nimport {last, shallowEqual} from './utils/collection';\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n * @param urlSerializer The `UrlSerializer` to use for handling query parameter normalization.\n * You should provide your application's custom `UrlSerializer` if one is configured to parse and\n * serialize query parameter values to and from objects other than strings/string arrays.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n  relativeTo: ActivatedRouteSnapshot,\n  commands: readonly any[],\n  queryParams: Params | null = null,\n  fragment: string | null = null,\n  urlSerializer = new DefaultUrlSerializer(),\n): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(\n    relativeToUrlSegmentGroup,\n    commands,\n    queryParams,\n    fragment,\n    urlSerializer,\n  );\n}\n\nexport function createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup | undefined;\n\n  function createSegmentGroupFromRouteRecursive(\n    currentRoute: ActivatedRouteSnapshot,\n  ): UrlSegmentGroup {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n  relativeTo: UrlSegmentGroup,\n  commands: readonly any[],\n  queryParams: Params | null,\n  fragment: string | null,\n  urlSerializer: UrlSerializer,\n): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment, urlSerializer);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment, urlSerializer);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren\n    ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n    : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\n/**\n * Normalizes a query parameter value by using the `UrlSerializer` to serialize then parse the value.\n *\n * This ensures that the value is consistent between parsing a URL in the browser on a fresh page load (or page refresh)\n * and a navigation where the query parameter value is passed directly to the router.\n *\n * This also allows custom `UrlSerializer` implementations to define how query parameter values are represented\n * in a `UrlTree`. Since `UrlSerializer` already has a `parse` that takes a string, it already has control\n * over how a browser URL is parsed into a `UrlTree` on initial load/page refresh.\n */\nfunction normalizeQueryParams(k: string, v: unknown, urlSerializer: UrlSerializer): unknown {\n  // Hack for empty string query param, which, for whatever reason, happens\n  // in a test. Parsing drops empty key params (which might not really be necessary).\n  // It's probably really a test issue but I don't have the time to fix it...\n  k ||= 'ɵ';\n  const tree = new UrlTree();\n  tree.queryParams = {[k]: v};\n  return urlSerializer.parse(urlSerializer.serialize(tree)).queryParams[k];\n}\n\nfunction tree(\n  oldRoot: UrlSegmentGroup,\n  oldSegmentGroup: UrlSegmentGroup,\n  newSegmentGroup: UrlSegmentGroup,\n  queryParams: Params | null,\n  fragment: string | null,\n  urlSerializer: UrlSerializer,\n): UrlTree {\n  const qp: Params = {};\n  for (const [key, value] of Object.entries(queryParams ?? {})) {\n    // This retains old behavior where each item in the array was stringified individually This\n    // helps remove special-case handling for empty and single-item arrays where the default\n    // serializer removes empty arrays when serialized then parsed or converts them to non-arrays\n    // for single-item arrays. Changing this could have breaking change implications. Prior code\n    // always returned arrays of strings for array inputs so tests, applications, serializers,\n    // etc. may only be set up to handle string arrays. We could consider changing this in the\n    // future to serialize the entire array as a single value. For now, this feels safer and is\n    // at least a step in the right direction.\n    qp[key] = Array.isArray(value)\n      ? value.map((v) => normalizeQueryParams(key, v, urlSerializer))\n      : normalizeQueryParams(key, value, urlSerializer);\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n  current: UrlSegmentGroup,\n  oldSegment: UrlSegmentGroup,\n  newSegment: UrlSegmentGroup,\n): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n    public isAbsolute: boolean,\n    public numberOfDoubleDots: number,\n    public commands: readonly any[],\n  ) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Root segment cannot have matrix parameters',\n      );\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          '{outlets:{}} has to be the last command',\n      );\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: readonly any[]): Navigation {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n    public segmentGroup: UrlSegmentGroup,\n    public processChildren: boolean,\n    public index: number,\n  ) {}\n}\n\nfunction findStartingPositionForTargetGroup(\n  nav: Navigation,\n  root: UrlSegmentGroup,\n  target: UrlSegmentGroup,\n): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n  group: UrlSegmentGroup,\n  index: number,\n  numberOfDoubleDots: number,\n): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DOUBLE_DOTS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\",\n      );\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: readonly unknown[]): {[k: string]: readonly unknown[] | string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n  segmentGroup: UrlSegmentGroup | undefined,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(\n      segmentGroup.segments.slice(m.pathIndex),\n      segmentGroup.children,\n    );\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (\n      Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n      segmentGroup.children[PRIMARY_OUTLET] &&\n      segmentGroup.numberOfChildren === 1 &&\n      segmentGroup.children[PRIMARY_OUTLET].segments.length === 0\n    ) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(\n        segmentGroup.children[PRIMARY_OUTLET],\n        startIndex,\n        commands,\n      );\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: readonly any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n      currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: readonly any[],\n): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: readonly unknown[] | string}): {\n  [outlet: string]: UrlSegmentGroup;\n} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationBehaviorOptions, Route} from './models';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {UrlTree} from './url_tree';\nimport type {Navigation} from './navigation_transition';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\nexport const IMPERATIVE_NAVIGATION = 'imperative';\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport enum EventType {\n  NavigationStart,\n  NavigationEnd,\n  NavigationCancel,\n  NavigationError,\n  RoutesRecognized,\n  ResolveStart,\n  ResolveEnd,\n  GuardsCheckStart,\n  GuardsCheckEnd,\n  RouteConfigLoadStart,\n  RouteConfigLoadEnd,\n  ChildActivationStart,\n  ChildActivationEnd,\n  ActivationStart,\n  ActivationEnd,\n  Scroll,\n  NavigationSkipped,\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/routing/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    public id: number,\n    /** The URL that is the destination for this navigation. */\n    public url: string,\n  ) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  readonly type = EventType.NavigationStart;\n\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see {@link NavigationEnd}\n   * @see {@link NavigationCancel}\n   * @see {@link NavigationError}\n   */\n  navigationTrigger?: NavigationTrigger;\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any; navigationId: number} | null;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    navigationTrigger: NavigationTrigger = 'imperative',\n    /** @docsNotRequired */\n    restoredState: {[k: string]: any; navigationId: number} | null = null,\n  ) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  readonly type = EventType.NavigationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport enum NavigationCancellationCode {\n  /**\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\n   */\n  Redirect,\n  /**\n   * A navigation failed because a more recent navigation started.\n   */\n  SupersededByNewNavigation,\n  /**\n   * A navigation failed because one of the resolvers completed without emitting a value.\n   */\n  NoDataFromResolver,\n  /**\n   * A navigation failed because a guard returned `false`.\n   */\n  GuardRejected,\n  /**\n   * A navigation was aborted by the `Navigation.abort` function.\n   *\n   * @see {@link Navigation}\n   */\n  Aborted,\n}\n\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nexport enum NavigationSkippedCode {\n  /**\n   * A navigation was skipped because the navigation URL was the same as the current Router URL.\n   */\n  IgnoredSameUrlNavigation,\n  /**\n   * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n   * the current Router URL and the target of the navigation.\n   *\n   * @see {@link UrlHandlingStrategy}\n   */\n  IgnoredByUrlHandlingStrategy,\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  readonly type = EventType.NavigationCancel;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationCancellationCode,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nexport class NavigationSkipped extends RouterEvent {\n  readonly type = EventType.NavigationSkipped;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\n     * instead for a stable skipped reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was skipped. This code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationSkippedCode,\n  ) {\n    super(id, url);\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  readonly type = EventType.NavigationError;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public error: any,\n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    readonly target?: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  readonly type = EventType.RoutesRecognized;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  readonly type = EventType.GuardsCheckStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  readonly type = EventType.GuardsCheckEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n    /** @docsNotRequired */\n    public shouldActivate: boolean,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  readonly type = EventType.ResolveStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  readonly type = EventType.ResolveEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  readonly type = EventType.RouteConfigLoadStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  readonly type = EventType.RouteConfigLoadEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  readonly type = EventType.ChildActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nexport class ChildActivationEnd {\n  readonly type = EventType.ChildActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationStart {\n  readonly type = EventType.ActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  readonly type = EventType.ActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  readonly type = EventType.Scroll;\n\n  constructor(\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd | NavigationSkipped,\n\n    /** @docsNotRequired */\n    readonly position: [number, number] | null,\n\n    /** @docsNotRequired */\n    readonly anchor: string | null,\n\n    /** @docsNotRequired */\n    readonly scrollBehavior?: 'manual' | 'after-transition',\n  ) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\nexport class BeforeActivateRoutes {}\nexport class RedirectRequest {\n  constructor(\n    readonly url: UrlTree,\n    readonly navigationBehaviorOptions: NavigationBehaviorOptions | undefined,\n  ) {}\n}\nexport type PrivateRouterEvents = BeforeActivateRoutes | RedirectRequest;\nexport function isPublicRouterEvent(e: Event | PrivateRouterEvents): e is Event {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](guide/routing/common-router-tasks#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event =\n  | NavigationStart\n  | NavigationEnd\n  | NavigationCancel\n  | NavigationError\n  | RoutesRecognized\n  | GuardsCheckStart\n  | GuardsCheckEnd\n  | RouteConfigLoadStart\n  | RouteConfigLoadEnd\n  | ChildActivationStart\n  | ChildActivationEnd\n  | ActivationStart\n  | ActivationEnd\n  | Scroll\n  | ResolveStart\n  | ResolveEnd\n  | NavigationSkipped;\n\nexport function stringifyEvent(routerEvent: Event): string {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position\n        ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\n        : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  createEnvironmentInjector,\n  EnvironmentInjector,\n  isStandalone,\n  Type,\n  ɵisNgModule as isNgModule,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Route, Routes} from '../models';\nimport {ActivatedRouteSnapshot} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nexport function getOrCreateRouteInjectorIfNeeded(\n  route: Route,\n  currentInjector: EnvironmentInjector,\n): EnvironmentInjector {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(\n      route.providers,\n      currentInjector,\n      `Route: ${route.path}`,\n    );\n  }\n  return route._injector ?? currentInjector;\n}\n\nexport function getLoadedRoutes(route: Route): Route[] | undefined {\n  return route._loadedRoutes;\n}\n\nexport function getLoadedInjector(route: Route): EnvironmentInjector | undefined {\n  return route._loadedInjector;\n}\nexport function getLoadedComponent(route: Route): Type<unknown> | undefined {\n  return route._loadedComponent;\n}\n\nexport function getProvidersInjector(route: Route): EnvironmentInjector | undefined {\n  return route._injector;\n}\n\nexport function validateConfig(\n  config: Routes,\n  parentPath: string = '',\n  requireStandaloneComponents = false,\n): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nexport function assertStandalone(fullPath: string, component: Type<unknown> | undefined): void {\n  if (component && isNgModule(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\n        `but it must be used with standalone components. Use 'loadChildren' instead.`,\n    );\n  } else if (component && !isStandalone(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. The component must be standalone.`,\n    );\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string, requireStandaloneComponents: boolean): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `,\n      );\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': Array cannot be specified`,\n      );\n    }\n    if (\n      !route.redirectTo &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren &&\n      route.outlet &&\n      route.outlet !== PRIMARY_OUTLET\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`,\n      );\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`,\n      );\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`,\n      );\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`,\n      );\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`,\n      );\n    }\n\n    if (route.redirectTo) {\n      if (route.component || route.loadComponent) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`,\n        );\n      }\n      if (route.canMatch || route.canActivate) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n          `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` +\n            `Redirects happen before guards are executed.`,\n        );\n      }\n    }\n\n    if (route.path && route.matcher) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`,\n      );\n    }\n    if (\n      route.redirectTo === void 0 &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`,\n      );\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`,\n      );\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path cannot start with a slash`,\n      );\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`,\n      );\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nexport function getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nexport function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n  const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nexport function getClosestRouteInjector(\n  snapshot: ActivatedRouteSnapshot | undefined,\n): EnvironmentInjector | null {\n  if (!snapshot) return null;\n\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, EnvironmentInjector, Injectable} from '@angular/core';\n\nimport type {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\nimport {getClosestRouteInjector} from './utils/config';\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract | null = null;\n  route: ActivatedRoute | null = null;\n  children: ChildrenOutletContexts;\n  attachRef: ComponentRef<any> | null = null;\n  get injector(): EnvironmentInjector {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n\n  constructor(private readonly rootInjector: EnvironmentInjector) {\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** @docs-private */\n  constructor(private rootInjector: EnvironmentInjector) {}\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>): void {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext | null {\n    return this.contexts.get(childName) || null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) {\n    this._root = root;\n  }\n\n  get root(): T {\n    return this._root.value;\n  }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T | null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map((t) => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T | null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map((c) => c.value);\n    return c.filter((cc) => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] {\n    return findPath(t, this._root).map((s) => s.value);\n  }\n}\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T> | null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(\n    public value: T,\n    public children: TreeNode<T>[],\n  ) {}\n\n  toString(): string {\n    return `TreeNode(${this.value})`;\n  }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends {outlet: string}>(\n  node: TreeNode<T> | null,\n): {\n  [outlet: string]: TreeNode<T>;\n} {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach((child) => (map[child.value.outlet] = child));\n  }\n\n  return map;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './models';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET, RouteTitleKey} from './shared';\nimport {equalSegments, UrlSegment} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n    root: TreeNode<ActivatedRoute>,\n    /** The current snapshot of the router state */\n    public snapshot: RouterStateSnapshot,\n  ) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  override toString(): string {\n    return this.snapshot.toString();\n  }\n}\n\nexport function createEmptyState(rootComponent: Type<any> | null): RouterState {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject<string | null>('');\n  const activated = new ActivatedRoute(\n    emptyUrl,\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    snapshot.root,\n  );\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(rootComponent: Type<any> | null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n    [],\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    null,\n    {},\n  );\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"}\n *\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot!: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState!: RouterState;\n  /** @internal */\n  _paramMap?: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap?: Observable<ParamMap>;\n\n  /** An Observable of the resolved route title */\n  readonly title: Observable<string | undefined>;\n\n  /** An observable of the URL segments matched by this route. */\n  public url: Observable<UrlSegment[]>;\n  /** An observable of the matrix parameters scoped to this route. */\n  public params: Observable<Params>;\n  /** An observable of the query parameters shared by all the routes. */\n  public queryParams: Observable<Params>;\n  /** An observable of the URL fragment shared by all the routes. */\n  public fragment: Observable<string | null>;\n  /** An observable of the static and resolved data of this route. */\n  public data: Observable<Data>;\n\n  /** @internal */\n  constructor(\n    /** @internal */\n    public urlSubject: BehaviorSubject<UrlSegment[]>,\n    /** @internal */\n    public paramsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public queryParamsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public fragmentSubject: BehaviorSubject<string | null>,\n    /** @internal */\n    public dataSubject: BehaviorSubject<Data>,\n    /** The outlet name of the route, a constant. */\n    public outlet: string,\n    /** The component of the route, a constant. */\n    public component: Type<any> | null,\n    futureSnapshot: ActivatedRouteSnapshot,\n  ) {\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map((d: Data) => d[RouteTitleKey])) ?? of(undefined);\n    // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route | null {\n    return this._futureSnapshot.routeConfig;\n  }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap(): Observable<ParamMap> {\n    this._paramMap ??= this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    this._queryParamMap ??= this.queryParams.pipe(\n      map((p: Params): ParamMap => convertToParamMap(p)),\n    );\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly' | 'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params;\n  data: Data;\n  resolve: Data;\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nexport function getInherited(\n  route: ActivatedRouteSnapshot,\n  parent: ActivatedRouteSnapshot | null,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n): Inherited {\n  let inherited: Inherited;\n  const {routeConfig} = route;\n  if (\n    parent !== null &&\n    (paramsInheritanceStrategy === 'always' ||\n      // inherit parent data if route is empty path\n      routeConfig?.path === '' ||\n      // inherit parent data if parent was componentless\n      (!parent.component && !parent.routeConfig?.loadComponent))\n  ) {\n    inherited = {\n      params: {...parent.params, ...route.params},\n      data: {...parent.data, ...route.data},\n      resolve: {\n        // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n        // change data because it's not frozen...\n        // This first line could be deleted chose to break/disallow mutating the `data` object in\n        // guards.\n        // Note that data from parents still override this mutated data so anyone relying on this\n        // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n        ...route.data,\n        // Ensure inherited resolved data overrides inherited static data\n        ...parent.data,\n        // static data from the current route overrides any inherited data\n        ...routeConfig?.data,\n        // resolved data from current route overrides everything\n        ...route._resolvedData,\n      },\n    };\n  } else {\n    inherited = {\n      params: {...route.params},\n      data: {...route.data},\n      resolve: {...route.data, ...(route._resolvedData ?? {})},\n    };\n  }\n\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class ActivatedRouteSnapshot {\n  /** The configuration used to match this route **/\n  public readonly routeConfig: Route | null;\n  /** @internal */\n  _resolve: ResolveData;\n  /** @internal */\n  _resolvedData?: Data;\n  /** @internal */\n  _routerState!: RouterStateSnapshot;\n  /** @internal */\n  _paramMap?: ParamMap;\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  /** The resolved route title */\n  get title(): string | undefined {\n    // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n    // available at the time of class instantiation.\n    return this.data?.[RouteTitleKey];\n  }\n\n  /** @internal */\n  constructor(\n    /** The URL segments matched by this route */\n    public url: UrlSegment[],\n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```ts\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    public params: Params,\n    /** The query parameters shared by all the routes */\n    public queryParams: Params,\n    /** The URL fragment shared by all the routes */\n    public fragment: string | null,\n    /** The static and resolved data of this route */\n    public data: Data,\n    /** The outlet name of the route */\n    public outlet: string,\n    /** The component of the route */\n    public component: Type<any> | null,\n    routeConfig: Route | null,\n    resolve: ResolveData,\n  ) {\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n\n  /** The root of the router state */\n  get root(): ActivatedRouteSnapshot {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree */\n  get parent(): ActivatedRouteSnapshot | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree */\n  get firstChild(): ActivatedRouteSnapshot | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree */\n  get children(): ActivatedRouteSnapshot[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot(): ActivatedRouteSnapshot[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  get paramMap(): ParamMap {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map((segment) => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n    /** The url from which this snapshot was created */\n    public url: string,\n    root: TreeNode<ActivatedRouteSnapshot>,\n  ) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  override toString(): string {\n    return serializeNode(this._root);\n  }\n}\n\nfunction setRouterState<U, T extends {_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach((c) => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\n\nexport function equalParamsAndUrlSegments(\n  a: ActivatedRouteSnapshot,\n  b: ActivatedRouteSnapshot,\n): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return (\n    equalUrlParams &&\n    !parentsMismatch &&\n    (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent!))\n  );\n}\n\nexport function hasStaticTitle(config: Route) {\n  return typeof config.title === 'string' || config.title === null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ComponentRef,\n  Directive,\n  EnvironmentInjector,\n  EventEmitter,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  Input,\n  input,\n  OnDestroy,\n  OnInit,\n  Output,\n  reflectComponentType,\n  ɵRuntimeError as RuntimeError,\n  Signal,\n  SimpleChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {combineLatest, of, Subscription} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n * @see [Page routerOutletData](guide/routing/show-routes-with-outlets#passing-contextual-data-to-routed-components)\n */\nexport const ROUTER_OUTLET_DATA = new InjectionToken<Signal<unknown | undefined>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'RouterOutlet data' : '',\n);\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see {@link ChildrenOutletContexts}\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object | null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute | null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Used to indicate that the outlet is able to bind data from the `Router` to the outlet\n   * component's inputs.\n   *\n   * When this is `undefined` or `false` and the developer has opted in to the\n   * feature using `withComponentInputBinding`, a warning will be logged in dev mode if this outlet\n   * is used in the application.\n   */\n  readonly supportsBindingToComponentInputs?: true;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: 'router-outlet',\n  exportAs: 'outlet',\n})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any> | null = null;\n  /** @internal */\n  get activatedComponentRef(): ComponentRef<any> | null {\n    return this.activated;\n  }\n  private _activatedRoute: ActivatedRoute | null = null;\n  /**\n   * The name of the outlet\n   *\n   */\n  @Input() name = PRIMARY_OUTLET;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  /**\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n   *\n   * When unset, the value of the token is `undefined` by default.\n   */\n  readonly routerOutletData = input<unknown>();\n\n  private parentContexts = inject(ChildrenOutletContexts);\n  private location = inject(ViewContainerRef);\n  private changeDetector = inject(ChangeDetectorRef);\n  private inputBinder = inject(INPUT_BINDER, {optional: true});\n  /** @docs-private */\n  readonly supportsBindingToComponentInputs = true;\n\n  /** @docs-private */\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['name']) {\n      const {firstChange, previousValue} = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n\n  private isTrackedInParentContexts(outletName: string) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n\n  /** @docs-private */\n  ngOnInit(): void {\n    this.initializeOutletWithName();\n  }\n\n  private initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void {\n    if (this.isActivated) {\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Cannot activate an already activated outlet',\n      );\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(\n      activatedRoute,\n      childContexts,\n      location.injector,\n      this.routerOutletData,\n    );\n\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector,\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n    private route: ActivatedRoute,\n    private childContexts: ChildrenOutletContexts,\n    private parent: Injector,\n    private outletData: Signal<unknown>,\n  ) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nexport const INPUT_BINDER = new InjectionToken<RoutedComponentInputBinder>('');\n\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n@Injectable()\nexport class RoutedComponentInputBinder {\n  private outletDataSubscriptions = new Map<RouterOutlet, Subscription>();\n\n  bindActivatedRouteToOutletComponent(outlet: RouterOutlet): void {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n\n  unsubscribeFromRouteData(outlet: RouterOutlet): void {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n\n  private subscribeToRouteData(outlet: RouterOutlet) {\n    const {activatedRoute} = outlet;\n    const dataSubscription = combineLatest([\n      activatedRoute.queryParams,\n      activatedRoute.params,\n      activatedRoute.data,\n    ])\n      .pipe(\n        switchMap(([queryParams, params, data], index) => {\n          data = {...queryParams, ...params, ...data};\n          // Get the first result from the data subscription synchronously so it's available to\n          // the component as soon as possible (and doesn't require a second change detection).\n          if (index === 0) {\n            return of(data);\n          }\n          // Promise.resolve is used to avoid synchronously writing the wrong data when\n          // two of the Observables in the `combineLatest` stream emit one after\n          // another.\n          return Promise.resolve(data);\n        }),\n      )\n      .subscribe((data) => {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (\n          !outlet.isActivated ||\n          !outlet.activatedComponentRef ||\n          outlet.activatedRoute !== activatedRoute ||\n          activatedRoute.component === null\n        ) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        for (const {templateName} of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Component} from '@angular/core';\n\nimport {RouterOutlet} from '../directives/router_outlet';\nimport {PRIMARY_OUTLET} from '../shared';\nimport {Route} from '../models';\nexport {ɵEmptyOutletComponent as EmptyOutletComponent};\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({\n  template: `<router-outlet/>`,\n  imports: [RouterOutlet],\n  // Used to avoid component ID collisions with user code.\n  exportAs: 'emptyRouterOutlet',\n})\nexport class ɵEmptyOutletComponent {}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if (\n    !c.component &&\n    !c.loadComponent &&\n    (children || c.loadChildren) &&\n    c.outlet &&\n    c.outlet !== PRIMARY_OUTLET\n  ) {\n    c.component = ɵEmptyOutletComponent;\n  }\n  return c;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: RouterStateSnapshot,\n  prevState: RouterState,\n): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState?: TreeNode<ActivatedRoute>,\n): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = (detachedRouteHandle as DetachedRouteHandleInternal).route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n    return new TreeNode<ActivatedRoute>(value, children);\n  }\n}\n\nfunction createOrReuseChildren(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState: TreeNode<ActivatedRoute>,\n) {\n  return curr.children.map((child) => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n    new BehaviorSubject(c.url),\n    new BehaviorSubject(c.params),\n    new BehaviorSubject(c.queryParams),\n    new BehaviorSubject(c.fragment),\n    new BehaviorSubject(c.data),\n    c.outlet,\n    c.component,\n    c,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationCancellationCode} from './events';\nimport {NavigationBehaviorOptions, RedirectCommand} from './models';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\n\nexport const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport type NavigationCancelingError = Error & {\n  [NAVIGATION_CANCELING_ERROR]: true;\n  cancellationCode: NavigationCancellationCode;\n};\nexport type RedirectingNavigationCancelingError = NavigationCancelingError & {\n  url: UrlTree;\n  navigationBehaviorOptions?: NavigationBehaviorOptions;\n  cancellationCode: NavigationCancellationCode.Redirect;\n};\n\nexport function redirectingNavigationError(\n  urlSerializer: UrlSerializer,\n  redirect: UrlTree | RedirectCommand,\n): RedirectingNavigationCancelingError {\n  const {redirectTo, navigationBehaviorOptions} = isUrlTree(redirect)\n    ? {redirectTo: redirect, navigationBehaviorOptions: undefined}\n    : redirect;\n  const error = navigationCancelingError(\n    ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`,\n    NavigationCancellationCode.Redirect,\n  ) as RedirectingNavigationCancelingError;\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nexport function navigationCancelingError(\n  message: string | null | false,\n  code: NavigationCancellationCode,\n) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`) as NavigationCancelingError;\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\n\nexport function isRedirectingNavigationCancelingError(\n  error: unknown | RedirectingNavigationCancelingError,\n): error is RedirectingNavigationCancelingError {\n  return (\n    isNavigationCancelingError(error) &&\n    isUrlTree((error as RedirectingNavigationCancelingError).url)\n  );\n}\n\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return !!error && (error as NavigationCancelingError)[NAVIGATION_CANCELING_ERROR];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport type {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, advanceActivatedRoute, RouterState} from '../router_state';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nlet warnedAboutUnsupportedInputBinding = false;\n\nexport const activateRoutes = (\n  rootContexts: ChildrenOutletContexts,\n  routeReuseStrategy: RouteReuseStrategy,\n  forwardEvent: (evt: Event) => void,\n  inputBindingEnabled: boolean,\n): MonoTypeOperatorFunction<NavigationTransition> =>\n  map((t) => {\n    new ActivateRoutes(\n      routeReuseStrategy,\n      t.targetRouterState!,\n      t.currentRouterState,\n      forwardEvent,\n      inputBindingEnabled,\n    ).activate(rootContexts);\n    return t;\n  });\n\nexport class ActivateRoutes {\n  constructor(\n    private routeReuseStrategy: RouteReuseStrategy,\n    private futureState: RouterState,\n    private currState: RouterState,\n    private forwardEvent: (evt: Event) => void,\n    private inputBindingEnabled: boolean,\n  ) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach((futureChild) => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    Object.values(children).forEach((v: TreeNode<ActivatedRoute>) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContext: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context) {\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n      // info\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n\n  private activateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach((c) => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = <DetachedRouteHandleInternal>(\n            this.routeReuseStrategy.retrieve(future.snapshot)\n          );\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (\n        outlet &&\n        this.inputBindingEnabled &&\n        !outlet.supportsBindingToComponentInputs &&\n        !warnedAboutUnsupportedInputBinding\n      ) {\n        console.warn(\n          `'withComponentInputBinding' feature is enabled but ` +\n            `this application is using an outlet that may not support binding to component inputs.`,\n        );\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, ProviderToken, ɵisInjectable as isInjectable} from '@angular/core';\n\nimport {RunGuardsAndResolvers} from '../models';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {\n  ActivatedRouteSnapshot,\n  equalParamsAndUrlSegments,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {shallowEqual} from '../utils/collection';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(\n    public component: Object | null,\n    public route: ActivatedRouteSnapshot,\n  ) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[];\n  canActivateChecks: CanActivate[];\n};\n\nexport function getAllRouteGuards(\n  future: RouterStateSnapshot,\n  curr: RouterStateSnapshot,\n  parentContexts: ChildrenOutletContexts,\n): Checks {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(\n  p: ActivatedRouteSnapshot,\n): {node: ActivatedRouteSnapshot; guards: any[]} | null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getTokenOrFunctionIdentity<T>(\n  tokenOrFunction: Function | ProviderToken<T>,\n  injector: Injector,\n): Function | T {\n  const NOT_FOUND = Symbol();\n  const result = injector.get<T | Symbol>(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !isInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get<T>(tokenOrFunction);\n    }\n  }\n  return result as T;\n}\n\nfunction getChildRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot> | null,\n  contexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach((c) => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  Object.entries(prevChildren).forEach(([k, v]: [string, TreeNode<ActivatedRouteSnapshot>]) =>\n    deactivateRouteAndItsChildren(v, contexts!.getContext(k), checks),\n  );\n\n  return checks;\n}\n\nfunction getRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot>,\n  parentContexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(\n      curr,\n      future,\n      future.routeConfig!.runGuardsAndResolvers,\n    );\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n        futureNode,\n        currNode,\n        context ? context.children : null,\n        futurePath,\n        checks,\n      );\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n  curr: ActivatedRouteSnapshot,\n  future: ActivatedRouteSnapshot,\n  mode: RunGuardsAndResolvers | undefined,\n): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return (\n        !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return (\n        !equalParamsAndUrlSegments(curr, future) ||\n        !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n  route: TreeNode<ActivatedRouteSnapshot>,\n  context: OutletContext | null,\n  checks: Checks,\n): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EmptyError} from 'rxjs';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn} from '../models';\nimport {\n  NAVIGATION_CANCELING_ERROR,\n  NavigationCancelingError,\n  RedirectingNavigationCancelingError,\n} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is {canLoad: CanLoadFn} {\n  return guard && isFunction<CanLoadFn>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is {canActivate: CanActivateFn} {\n  return guard && isFunction<CanActivateFn>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is {canActivateChild: CanActivateChildFn} {\n  return guard && isFunction<CanActivateChildFn>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is {canDeactivate: CanDeactivateFn<T>} {\n  return guard && isFunction<CanDeactivateFn<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is {canMatch: CanMatchFn} {\n  return guard && isFunction<CanMatchFn>(guard.canMatch);\n}\n\nexport function isEmptyError(e: Error): e is EmptyError {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {combineLatest, Observable, OperatorFunction} from 'rxjs';\nimport {filter, map, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {GuardResult, RedirectCommand} from '../models';\nimport {isUrlTree, UrlTree} from '../url_tree';\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | GuardResult;\n\nexport function prioritizedGuardValue(): OperatorFunction<Observable<GuardResult>[], GuardResult> {\n  return switchMap((obs) => {\n    return combineLatest(\n      obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))),\n    ).pipe(\n      map((results: INTERIM_VALUES[]) => {\n        for (const result of results) {\n          if (result === true) {\n            // If result is true, check the next one\n            continue;\n          } else if (result === INITIAL_VALUE) {\n            // If guard has not finished, we need to stop processing.\n            return INITIAL_VALUE;\n          } else if (result === false || isRedirect(result)) {\n            // Result finished and was not true. Return the result.\n            // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n            // ignored.\n            return result;\n          }\n        }\n        // Everything resolved to true. Return true.\n        return true;\n      }),\n      filter((item): item is GuardResult => item !== INITIAL_VALUE),\n      take(1),\n    );\n  });\n}\n\nfunction isRedirect(val: INTERIM_VALUES): val is UrlTree | RedirectCommand {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable, of} from 'rxjs';\nimport {take, takeUntil} from 'rxjs/operators';\n\n/**\n * Converts an AbortSignal to an Observable<void>.\n * Emits and completes when the signal is aborted.\n * If the signal is already aborted, it emits and completes immediately.\n */\nexport function abortSignalToObservable(signal: AbortSignal): Observable<void> {\n  if (signal.aborted) {\n    return of(undefined).pipe(take(1)); // Emit and complete immediately\n  }\n  return new Observable<void>((subscriber) => {\n    const handler = () => {\n      subscriber.next();\n      subscriber.complete();\n    };\n    signal.addEventListener('abort', handler);\n    return () => signal.removeEventListener('abort', handler);\n  });\n}\n\nexport function takeUntilAbort<T>(signal: AbortSignal) {\n  return takeUntil<T>(abortSignalToObservable(signal));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {\n  concat,\n  defer,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n} from 'rxjs';\nimport {concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {\n  CanActivateChildFn,\n  CanActivateFn,\n  CanDeactivateFn,\n  GuardResult,\n  CanLoadFn,\n  CanMatchFn,\n  Route,\n} from '../models';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {UrlSegment, UrlSerializer} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {\n  CanActivate,\n  CanDeactivate,\n  getCanActivateChild,\n  getTokenOrFunctionIdentity,\n} from '../utils/preactivation';\nimport {\n  isBoolean,\n  isCanActivate,\n  isCanActivateChild,\n  isCanDeactivate,\n  isCanLoad,\n  isCanMatch,\n} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\nimport {takeUntilAbort} from '../utils/abort_signal_to_observable';\n\nexport function checkGuards(\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {canActivateChecks, canDeactivateChecks},\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({...t, guardsResult: true});\n    }\n\n    return runCanDeactivateChecks(\n      canDeactivateChecks,\n      targetSnapshot!,\n      currentSnapshot,\n      injector,\n    ).pipe(\n      mergeMap((canDeactivate) => {\n        return canDeactivate && isBoolean(canDeactivate)\n          ? runCanActivateChecks(targetSnapshot!, canActivateChecks, injector, forwardEvent)\n          : of(canDeactivate);\n      }),\n      map((guardsResult) => ({...t, guardsResult})),\n    );\n  });\n}\n\nfunction runCanDeactivateChecks(\n  checks: CanDeactivate[],\n  futureRSS: RouterStateSnapshot,\n  currRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n) {\n  return from(checks).pipe(\n    mergeMap((check) =>\n      runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector),\n    ),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\nfunction runCanActivateChecks(\n  futureSnapshot: RouterStateSnapshot,\n  checks: CanActivate[],\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n) {\n  return from(checks).pipe(\n    concatMap((check: CanActivate) => {\n      return concat(\n        fireChildActivationStart(check.route.parent, forwardEvent),\n        fireActivationStart(check.route, forwardEvent),\n        runCanActivateChild(futureSnapshot, check.path, injector),\n        runCanActivate(futureSnapshot, check.route, injector),\n      );\n    }),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\n\nfunction runCanActivate(\n  futureRSS: RouterStateSnapshot,\n  futureARS: ActivatedRouteSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n\n  const canActivateObservables = canActivate.map((canActivate) => {\n    return defer(() => {\n      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n      const guard = getTokenOrFunctionIdentity<CanActivate>(\n        canActivate as ProviderToken<CanActivate>,\n        closestInjector,\n      );\n      const guardVal = isCanActivate(guard)\n        ? guard.canActivate(futureARS, futureRSS)\n        : runInInjectionContext(closestInjector, () =>\n            (guard as CanActivateFn)(futureARS, futureRSS),\n          );\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n  futureRSS: RouterStateSnapshot,\n  path: ActivatedRouteSnapshot[],\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path\n    .slice(0, path.length - 1)\n    .reverse()\n    .map((p) => getCanActivateChild(p))\n    .filter((_) => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(\n        (canActivateChild: CanActivateChildFn | ProviderToken<unknown>) => {\n          const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n          const guard = getTokenOrFunctionIdentity<{canActivateChild: CanActivateChildFn}>(\n            canActivateChild,\n            closestInjector,\n          );\n          const guardVal = isCanActivateChild(guard)\n            ? guard.canActivateChild(futureARS, futureRSS)\n            : runInInjectionContext(closestInjector, () =>\n                (guard as CanActivateChildFn)(futureARS, futureRSS),\n              );\n          return wrapIntoObservable(guardVal).pipe(first());\n        },\n      );\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n  component: Object | null,\n  currARS: ActivatedRouteSnapshot,\n  currRSS: RouterStateSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity<any>(c, closestInjector);\n    const guardVal = isCanDeactivate(guard)\n      ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\n      : runInInjectionContext(closestInjector, () =>\n          (guard as CanDeactivateFn<any>)(component, currARS, currRSS, futureRSS),\n        );\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nexport function runCanLoadGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n  abortSignal?: AbortSignal,\n): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  const canLoadObservables = canLoad.map((injectionToken: any) => {\n    const guard = getTokenOrFunctionIdentity<any>(injectionToken, injector);\n    const guardVal = isCanLoad(guard)\n      ? guard.canLoad(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanLoadFn)(route, segments));\n    const obs$ = wrapIntoObservable(guardVal);\n    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;\n  });\n\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nfunction redirectIfUrlTree(urlSerializer: UrlSerializer): OperatorFunction<GuardResult, boolean> {\n  return pipe(\n    tap((result: GuardResult) => {\n      if (typeof result === 'boolean') return;\n\n      throw redirectingNavigationError(urlSerializer, result);\n    }),\n    map((result) => result === true),\n  );\n}\n\nexport function runCanMatchGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n  abortSignal?: AbortSignal,\n): Observable<GuardResult> {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n\n  const canMatchObservables = canMatch.map((injectionToken) => {\n    const guard = getTokenOrFunctionIdentity(injectionToken as ProviderToken<any>, injector);\n    const guardVal = isCanMatch(guard)\n      ? guard.canMatch(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanMatchFn)(route, segments));\n    let obs$ = wrapIntoObservable(guardVal);\n    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;\n  });\n\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, runInInjectionContext, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {RedirectFunction, Route} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {wrapIntoObservable} from './utils/collection';\nimport {firstValueFrom} from './utils/first_value_from';\n\nexport class NoMatch extends Error {\n  public segmentGroup: UrlSegmentGroup | null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    super();\n    this.segmentGroup = segmentGroup || null;\n\n    // Extending `Error` ends up breaking some internal tests. This appears to be a known issue\n    // when extending errors in TS and the workaround is to explicitly set the prototype.\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, NoMatch.prototype);\n  }\n}\n\nexport class AbsoluteRedirect extends Error {\n  constructor(public urlTree: UrlTree) {\n    super();\n\n    // Extending `Error` ends up breaking some internal tests. This appears to be a known issue\n    // when extending errors in TS and the workaround is to explicitly set the prototype.\n    // https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    Object.setPrototypeOf(this, AbsoluteRedirect.prototype);\n  }\n}\n\nexport function namedOutletsRedirect(redirectTo: string): never {\n  throw new RuntimeError(\n    RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`,\n  );\n}\n\nexport function canLoadFails(route: Route): never {\n  throw navigationCancelingError(\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`,\n    NavigationCancellationCode.GuardRejected,\n  );\n}\n\nexport class ApplyRedirects {\n  constructor(\n    private urlSerializer: UrlSerializer,\n    private urlTree: UrlTree,\n  ) {}\n\n  async lineralizeSegments(route: Route, urlTree: UrlTree): Promise<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return res;\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        throw namedOutletsRedirect(`${route.redirectTo!}`);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  async applyRedirectCommands(\n    segments: UrlSegment[],\n    redirectTo: string | RedirectFunction,\n    posParams: {[k: string]: UrlSegment},\n    currentSnapshot: ActivatedRouteSnapshot,\n    injector: Injector,\n  ): Promise<UrlTree> {\n    const redirect = await getRedirectResult(redirectTo, currentSnapshot, injector);\n    if (redirect instanceof UrlTree) {\n      throw new AbsoluteRedirect(redirect);\n    }\n\n    const newTree = this.applyRedirectCreateUrlTree(\n      redirect,\n      this.urlSerializer.parse(redirect),\n      segments,\n      posParams,\n    );\n\n    if (redirect[0] === '/') {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n\n  applyRedirectCreateUrlTree(\n    redirectTo: string,\n    urlTree: UrlTree,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n      newRoot,\n      this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n      urlTree.fragment,\n    );\n  }\n\n  createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  createSegmentGroup(\n    redirectTo: string,\n    group: UrlSegmentGroup,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  createSegments(\n    redirectTo: string,\n    redirectToSegments: UrlSegment[],\n    actualSegments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment[] {\n    return redirectToSegments.map((s) =>\n      s.path[0] === ':'\n        ? this.findPosParam(redirectTo, s, posParams)\n        : this.findOrReturn(s, actualSegments),\n    );\n  }\n\n  findPosParam(\n    redirectTo: string,\n    redirectToUrlSegment: UrlSegment,\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_REDIRECT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`,\n      );\n    return pos;\n  }\n\n  findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n\nfunction getRedirectResult(\n  redirectTo: string | RedirectFunction,\n  currentSnapshot: ActivatedRouteSnapshot,\n  injector: Injector,\n): Promise<string | UrlTree> {\n  if (typeof redirectTo === 'string') {\n    return Promise.resolve(redirectTo);\n  }\n  const redirectToFn = redirectTo;\n  const {queryParams, fragment, routeConfig, url, outlet, params, data, title} = currentSnapshot;\n  return firstValueFrom(\n    wrapIntoObservable(\n      runInInjectionContext(injector, () =>\n        redirectToFn({params, data, queryParams, fragment, routeConfig, url, outlet, title}),\n      ),\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {runCanMatchGuards} from '../operators/check_guards';\nimport {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer} from '../url_tree';\n\nimport {last} from './collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet} from './config';\n\nexport interface MatchResult {\n  matched: boolean;\n  consumedSegments: UrlSegment[];\n  remainingSegments: UrlSegment[];\n  parameters: {[k: string]: string};\n  positionalParamSegments: {[k: string]: UrlSegment};\n}\n\nconst noMatch: MatchResult = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {},\n};\n\nexport function matchWithChecks(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n  injector: EnvironmentInjector,\n  urlSerializer: UrlSerializer,\n  abortSignal?: AbortSignal,\n): Observable<MatchResult> {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal).pipe(\n    map((v) => (v === true ? result : {...noMatch})),\n  );\n}\n\nexport function match(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n): MatchResult {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {...noMatch};\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {},\n    };\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {...noMatch};\n\n  const posParams: {[n: string]: string} = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters =\n    res.consumed.length > 0\n      ? {...posParams, ...res.consumed[res.consumed.length - 1].parameters}\n      : posParams;\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {},\n  };\n}\n\nexport function split(\n  segmentGroup: UrlSegmentGroup,\n  consumedSegments: UrlSegment[],\n  slicedSegments: UrlSegment[],\n  config: Route[],\n): {\n  segmentGroup: UrlSegmentGroup;\n  slicedSegments: UrlSegment[];\n} {\n  if (\n    slicedSegments.length > 0 &&\n    containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      consumedSegments,\n      createChildrenForEmptyPaths(\n        config,\n        new UrlSegmentGroup(slicedSegments, segmentGroup.children),\n      ),\n    );\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (\n    slicedSegments.length === 0 &&\n    containsEmptyPathMatches(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      segmentGroup.segments,\n      addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children),\n    );\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n  children: {[name: string]: UrlSegmentGroup},\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n  routes: Route[],\n  primarySegment: UrlSegmentGroup,\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some(\n    (r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET,\n  );\n}\n\nfunction containsEmptyPathMatches(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nexport function emptyPathMatch(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  r: Route,\n): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n\nexport function noLeftoversInUrl(\n  segmentGroup: UrlSegmentGroup,\n  segments: UrlSegment[],\n  outlet: string,\n): boolean {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {AbsoluteRedirect, ApplyRedirects, canLoadFails, NoMatch} from './apply_redirects';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  ParamsInheritanceStrategy,\n  RouterStateSnapshot,\n} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {\n  emptyPathMatch,\n  match,\n  MatchResult,\n  matchWithChecks,\n  noLeftoversInUrl,\n  split,\n} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {firstValueFrom} from './utils/first_value_from';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport async function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Routes,\n  urlTree: UrlTree,\n  urlSerializer: UrlSerializer,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n  abortSignal: AbortSignal,\n): Promise<{state: RouterStateSnapshot; tree: UrlTree}> {\n  return new Recognizer(\n    injector,\n    configLoader,\n    rootComponentType,\n    config,\n    urlTree,\n    paramsInheritanceStrategy,\n    urlSerializer,\n    abortSignal,\n  ).recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects: ApplyRedirects;\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n    private injector: EnvironmentInjector,\n    private configLoader: RouterConfigLoader,\n    private rootComponentType: Type<any> | null,\n    private config: Routes,\n    private urlTree: UrlTree,\n    private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n    private readonly urlSerializer: UrlSerializer,\n    private readonly abortSignal: AbortSignal,\n  ) {\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n\n  private noMatchError(e: NoMatch): RuntimeError<RuntimeErrorCode.NO_MATCH> {\n    return new RuntimeError(\n      RuntimeErrorCode.NO_MATCH,\n      typeof ngDevMode === 'undefined' || ngDevMode\n        ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n        : `'${e.segmentGroup}'`,\n    );\n  }\n\n  async recognize(): Promise<{state: RouterStateSnapshot; tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    const {children, rootSnapshot} = await this.match(rootSegmentGroup);\n    const rootNode = new TreeNode(rootSnapshot, children);\n    const routeState = new RouterStateSnapshot('', rootNode);\n    const tree = createUrlTreeFromSnapshot(\n      rootSnapshot,\n      [],\n      this.urlTree.queryParams,\n      this.urlTree.fragment,\n    );\n    // Creating the tree stringifies the query params\n    // We don't want to do this here to preserve pre-existing behavior\n    // so reassign them to the original.\n    tree.queryParams = this.urlTree.queryParams;\n    routeState.url = this.urlSerializer.serialize(tree);\n    return {state: routeState, tree};\n  }\n\n  private async match(rootSegmentGroup: UrlSegmentGroup): Promise<{\n    children: TreeNode<ActivatedRouteSnapshot>[];\n    rootSnapshot: ActivatedRouteSnapshot;\n  }> {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot(\n      [],\n      Object.freeze({}),\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      Object.freeze({}),\n      PRIMARY_OUTLET,\n      this.rootComponentType,\n      null,\n      {},\n    );\n    try {\n      const children = await this.processSegmentGroup(\n        this.injector,\n        this.config,\n        rootSegmentGroup,\n        PRIMARY_OUTLET,\n        rootSnapshot,\n      );\n      return {children, rootSnapshot};\n    } catch (e: any) {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }\n  }\n\n  async processSegmentGroup(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n\n    const child = await this.processSegment(\n      injector,\n      config,\n      segmentGroup,\n      segmentGroup.segments,\n      outlet,\n      true,\n      parentRoute,\n    );\n    return child instanceof TreeNode ? [child] : [];\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  async processChildren(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n\n    let children: TreeNode<ActivatedRouteSnapshot>[] = [];\n    for (const childOutlet of childOutlets) {\n      const child = segmentGroup.children[childOutlet];\n      // Sort the config so that routes with outlets that match the one being activated\n      // appear first, followed by routes for other outlets, which might match if they have\n      // an empty path.\n      const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n      const outletChildren = await this.processSegmentGroup(\n        injector,\n        sortedConfig,\n        child,\n        childOutlet,\n        parentRoute,\n      );\n      children.push(...outletChildren);\n    }\n\n    // Because we may have matched two outlets to the same empty path segment, we can have\n    // multiple activated results for the same outlet. We should merge the children of\n    // these results so the final return value is only one `TreeNode` per outlet.\n    const mergedChildren = mergeEmptyPathMatches(children);\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      // This should really never happen - we are only taking the first match for each\n      // outlet and merge the empty path matches.\n      checkOutletNameUniqueness(mergedChildren);\n    }\n    sortActivatedRouteSnapshots(mergedChildren);\n    return mergedChildren;\n  }\n\n  async processSegment(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    segmentGroup: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    for (const r of routes) {\n      try {\n        return await this.processSegmentAgainstRoute(\n          r._injector ?? injector,\n          routes,\n          r,\n          segmentGroup,\n          segments,\n          outlet,\n          allowRedirects,\n          parentRoute,\n        );\n      } catch (e: any) {\n        if (e instanceof NoMatch || isEmptyError(e)) {\n          continue;\n        }\n        throw e;\n      }\n    }\n\n    if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n      return new NoLeftoversInUrl();\n    }\n    throw new NoMatch(segmentGroup);\n  }\n\n  async processSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    route: Route,\n    rawSegment: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (\n      getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))\n    ) {\n      throw new NoMatch(rawSegment);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(\n        injector,\n        rawSegment,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n        injector,\n        rawSegment,\n        routes,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    throw new NoMatch(rawSegment);\n  }\n\n  private async expandSegmentAgainstRouteUsingRedirect(\n    injector: EnvironmentInjector,\n    segmentGroup: UrlSegmentGroup,\n    routes: Route[],\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    const {matched, parameters, consumedSegments, positionalParamSegments, remainingSegments} =\n      match(segmentGroup, route, segments);\n    if (!matched) throw new NoMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n            RuntimeErrorCode.INFINITE_REDIRECT,\n            `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n              `This is currently a dev mode only error but will become a` +\n              ` call stack size exceeded error in production in a future major version.`,\n          );\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(\n      segments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    if (this.abortSignal.aborted) {\n      throw new Error(this.abortSignal.reason);\n    }\n    const newTree = await this.applyRedirects.applyRedirectCommands(\n      consumedSegments,\n      route.redirectTo!,\n      positionalParamSegments,\n      currentSnapshot,\n      injector,\n    );\n\n    const newSegments = await this.applyRedirects.lineralizeSegments(route, newTree);\n    return this.processSegment(\n      injector,\n      routes,\n      segmentGroup,\n      newSegments.concat(remainingSegments),\n      outlet,\n      false,\n      parentRoute,\n    );\n  }\n\n  async matchSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    rawSegment: UrlSegmentGroup,\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Promise<TreeNode<ActivatedRouteSnapshot>> {\n    if (this.abortSignal.aborted) {\n      throw new Error(this.abortSignal.reason);\n    }\n    const result = await firstValueFrom(\n      matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer, this.abortSignal),\n    );\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n\n    if (!result?.matched) {\n      throw new NoMatch(rawSegment);\n    }\n    // If the route has an injector created from providers, we should start using that.\n    injector = route._injector ?? injector;\n    const {routes: childConfig} = await this.getChildConfig(injector, route, segments);\n    const childInjector = route._loadedInjector ?? injector;\n\n    const {parameters, consumedSegments, remainingSegments} = result;\n    const snapshot = new ActivatedRouteSnapshot(\n      consumedSegments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n    snapshot.params = Object.freeze(inherited.params);\n    snapshot.data = Object.freeze(inherited.data);\n\n    const {segmentGroup, slicedSegments} = split(\n      rawSegment,\n      consumedSegments,\n      remainingSegments,\n      childConfig,\n    );\n\n    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n      const children = await this.processChildren(\n        childInjector,\n        childConfig,\n        segmentGroup,\n        snapshot,\n      );\n      return new TreeNode(snapshot, children);\n    }\n\n    if (childConfig.length === 0 && slicedSegments.length === 0) {\n      return new TreeNode(snapshot, []);\n    }\n\n    const matchedOnOutlet = getOutlet(route) === outlet;\n    // If we matched a config due to empty path match on a different outlet, we need to\n    // continue passing the current outlet for the segment rather than switch to PRIMARY.\n    // Note that we switch to primary when we have a match because outlet configs look like\n    // this: {path: 'a', outlet: 'a', children: [\n    //  {path: 'b', component: B},\n    //  {path: 'c', component: C},\n    // ]}\n    // Notice that the children of the named outlet are configured with the primary outlet\n    const child = await this.processSegment(\n      childInjector,\n      childConfig,\n      segmentGroup,\n      slicedSegments,\n      matchedOnOutlet ? PRIMARY_OUTLET : outlet,\n      true,\n      snapshot,\n    );\n    return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n  }\n  private async getChildConfig(\n    injector: EnvironmentInjector,\n    route: Route,\n    segments: UrlSegment[],\n  ): Promise<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return {routes: route.children, injector};\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return {routes: route._loadedRoutes, injector: route._loadedInjector!};\n      }\n\n      if (this.abortSignal.aborted) {\n        throw new Error(this.abortSignal.reason);\n      }\n      const shouldLoadResult = await firstValueFrom(\n        runCanLoadGuards(injector, route, segments, this.urlSerializer, this.abortSignal),\n      );\n      if (shouldLoadResult) {\n        const cfg = await this.configLoader.loadChildren(injector, route);\n        route._loadedRoutes = cfg.routes;\n        route._loadedInjector = cfg.injector;\n        return cfg;\n      }\n      throw canLoadFails(route);\n    }\n\n    return {routes: [], injector};\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(\n  nodes: Array<TreeNode<ActivatedRouteSnapshot>>,\n): Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode = result.find(\n      (resultNode) => node.value.routeConfig === resultNode.value.routeConfig,\n    );\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n      const c = n.value.url.map((s) => s.toString()).join('/');\n      throw new RuntimeError(\n        RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Two segments cannot have the same outlet name: '${p}' and '${c}'.`,\n      );\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, runInInjectionContext, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {Observable, of, throwError} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {LoadedRouterConfig, RedirectFunction, Route} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {wrapIntoObservable} from './utils/collection';\n\nexport class NoMatch {\n  public segmentGroup: UrlSegmentGroup | null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\n\nexport class AbsoluteRedirect extends Error {\n  constructor(public urlTree: UrlTree) {\n    super();\n  }\n}\n\nexport function noMatch(segmentGroup: UrlSegmentGroup): Observable<any> {\n  return throwError(new NoMatch(segmentGroup));\n}\n\nexport function absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nexport function namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return throwError(\n    new RuntimeError(\n      RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`,\n    ),\n  );\n}\n\nexport function canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return throwError(\n    navigationCancelingError(\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`,\n      NavigationCancellationCode.GuardRejected,\n    ),\n  );\n}\n\nexport class ApplyRedirects {\n  constructor(\n    private urlSerializer: UrlSerializer,\n    private urlTree: UrlTree,\n  ) {}\n\n  lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo!}`);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  applyRedirectCommands(\n    segments: UrlSegment[],\n    redirectTo: string | RedirectFunction,\n    posParams: {[k: string]: UrlSegment},\n    currentSnapshot: ActivatedRouteSnapshot,\n    injector: Injector,\n  ): Observable<UrlTree> {\n    return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(\n      map((redirect) => {\n        if (redirect instanceof UrlTree) {\n          throw new AbsoluteRedirect(redirect);\n        }\n\n        const newTree = this.applyRedirectCreateUrlTree(\n          redirect,\n          this.urlSerializer.parse(redirect),\n          segments,\n          posParams,\n        );\n\n        if (redirect[0] === '/') {\n          throw new AbsoluteRedirect(newTree);\n        }\n        return newTree;\n      }),\n    );\n  }\n\n  applyRedirectCreateUrlTree(\n    redirectTo: string,\n    urlTree: UrlTree,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n      newRoot,\n      this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n      urlTree.fragment,\n    );\n  }\n\n  createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  createSegmentGroup(\n    redirectTo: string,\n    group: UrlSegmentGroup,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  createSegments(\n    redirectTo: string,\n    redirectToSegments: UrlSegment[],\n    actualSegments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment[] {\n    return redirectToSegments.map((s) =>\n      s.path[0] === ':'\n        ? this.findPosParam(redirectTo, s, posParams)\n        : this.findOrReturn(s, actualSegments),\n    );\n  }\n\n  findPosParam(\n    redirectTo: string,\n    redirectToUrlSegment: UrlSegment,\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_REDIRECT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`,\n      );\n    return pos;\n  }\n\n  findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n\nfunction getRedirectResult(\n  redirectTo: string | RedirectFunction,\n  currentSnapshot: ActivatedRouteSnapshot,\n  injector: Injector,\n): Observable<string | UrlTree> {\n  if (typeof redirectTo === 'string') {\n    return of(redirectTo);\n  }\n  const redirectToFn = redirectTo;\n  const {queryParams, fragment, routeConfig, url, outlet, params, data, title} = currentSnapshot;\n  return wrapIntoObservable(\n    runInInjectionContext(injector, () =>\n      redirectToFn({params, data, queryParams, fragment, routeConfig, url, outlet, title}),\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type, ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  defaultIfEmpty,\n  first,\n  last,\n  map,\n  mergeMap,\n  scan,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport {\n  AbsoluteRedirect,\n  ApplyRedirects,\n  canLoadFails,\n  noMatch,\n  NoMatch,\n} from './apply_redirects_rxjs';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  ParamsInheritanceStrategy,\n  RouterStateSnapshot,\n} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {\n  emptyPathMatch,\n  match,\n  matchWithChecks,\n  noLeftoversInUrl,\n  split,\n} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Routes,\n  urlTree: UrlTree,\n  urlSerializer: UrlSerializer,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n  abortSignal: AbortSignal,\n): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n  return new Recognizer(\n    injector,\n    configLoader,\n    rootComponentType,\n    config,\n    urlTree,\n    paramsInheritanceStrategy,\n    urlSerializer,\n  ).recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects: ApplyRedirects;\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n    private injector: EnvironmentInjector,\n    private configLoader: RouterConfigLoader,\n    private rootComponentType: Type<any> | null,\n    private config: Routes,\n    private urlTree: UrlTree,\n    private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n    private readonly urlSerializer: UrlSerializer,\n  ) {\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n\n  private noMatchError(e: NoMatch): RuntimeError<RuntimeErrorCode.NO_MATCH> {\n    return new RuntimeError(\n      RuntimeErrorCode.NO_MATCH,\n      typeof ngDevMode === 'undefined' || ngDevMode\n        ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n        : `'${e.segmentGroup}'`,\n    );\n  }\n\n  recognize(): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    return this.match(rootSegmentGroup).pipe(\n      map(({children, rootSnapshot}) => {\n        const rootNode = new TreeNode(rootSnapshot, children);\n        const routeState = new RouterStateSnapshot('', rootNode);\n        const tree = createUrlTreeFromSnapshot(\n          rootSnapshot,\n          [],\n          this.urlTree.queryParams,\n          this.urlTree.fragment,\n        );\n        // https://github.com/angular/angular/issues/47307\n        // Creating the tree stringifies the query params\n        // We don't want to do this here so reassign them to the original.\n        tree.queryParams = this.urlTree.queryParams;\n        routeState.url = this.urlSerializer.serialize(tree);\n        return {state: routeState, tree};\n      }),\n    );\n  }\n\n  private match(rootSegmentGroup: UrlSegmentGroup): Observable<{\n    children: TreeNode<ActivatedRouteSnapshot>[];\n    rootSnapshot: ActivatedRouteSnapshot;\n  }> {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot(\n      [],\n      Object.freeze({}),\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      Object.freeze({}),\n      PRIMARY_OUTLET,\n      this.rootComponentType,\n      null,\n      {},\n    );\n    return this.processSegmentGroup(\n      this.injector,\n      this.config,\n      rootSegmentGroup,\n      PRIMARY_OUTLET,\n      rootSnapshot,\n    ).pipe(\n      map((children) => {\n        return {children, rootSnapshot};\n      }),\n      catchError((e: any) => {\n        if (e instanceof AbsoluteRedirect) {\n          this.urlTree = e.urlTree;\n          return this.match(e.urlTree.root);\n        }\n        if (e instanceof NoMatch) {\n          throw this.noMatchError(e);\n        }\n\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentGroup(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n\n    return this.processSegment(\n      injector,\n      config,\n      segmentGroup,\n      segmentGroup.segments,\n      outlet,\n      true,\n      parentRoute,\n    ).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(\n      concatMap((childOutlet) => {\n        const child = segmentGroup.children[childOutlet];\n        // Sort the config so that routes with outlets that match the one being activated\n        // appear first, followed by routes for other outlets, which might match if they have\n        // an empty path.\n        const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n      }),\n      scan((children, outletChildren) => {\n        children.push(...outletChildren);\n        return children;\n      }),\n      defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n      last(),\n      mergeMap((children) => {\n        if (children === null) return noMatch(segmentGroup);\n        // Because we may have matched two outlets to the same empty path segment, we can have\n        // multiple activated results for the same outlet. We should merge the children of\n        // these results so the final return value is only one `TreeNode` per outlet.\n        const mergedChildren = mergeEmptyPathMatches(children);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // This should really never happen - we are only taking the first match for each\n          // outlet and merge the empty path matches.\n          checkOutletNameUniqueness(mergedChildren);\n        }\n        sortActivatedRouteSnapshots(mergedChildren);\n        return of(mergedChildren);\n      }),\n    );\n  }\n\n  processSegment(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    segmentGroup: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    return from(routes).pipe(\n      concatMap((r) => {\n        return this.processSegmentAgainstRoute(\n          r._injector ?? injector,\n          routes,\n          r,\n          segmentGroup,\n          segments,\n          outlet,\n          allowRedirects,\n          parentRoute,\n        ).pipe(\n          catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              return of(null);\n            }\n            throw e;\n          }),\n        );\n      }),\n      first((x): x is TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl => !!x),\n      catchError((e) => {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new NoLeftoversInUrl());\n          }\n          return noMatch(segmentGroup);\n        }\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    route: Route,\n    rawSegment: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (\n      getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))\n    ) {\n      return noMatch(rawSegment);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(\n        injector,\n        rawSegment,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n        injector,\n        rawSegment,\n        routes,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    return noMatch(rawSegment);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n    injector: EnvironmentInjector,\n    segmentGroup: UrlSegmentGroup,\n    routes: Route[],\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    const {matched, parameters, consumedSegments, positionalParamSegments, remainingSegments} =\n      match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n            RuntimeErrorCode.INFINITE_REDIRECT,\n            `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n              `This is currently a dev mode only error but will become a` +\n              ` call stack size exceeded error in production in a future major version.`,\n          );\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(\n      segments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree$: Observable<UrlTree> = this.applyRedirects.applyRedirectCommands(\n      consumedSegments,\n      route.redirectTo!,\n      positionalParamSegments,\n      currentSnapshot,\n      injector,\n    );\n\n    return newTree$.pipe(\n      switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)),\n      mergeMap((newSegments: UrlSegment[]) => {\n        return this.processSegment(\n          injector,\n          routes,\n          segmentGroup,\n          newSegments.concat(remainingSegments),\n          outlet,\n          false,\n          parentRoute,\n        );\n      }),\n    );\n  }\n\n  matchSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    rawSegment: UrlSegmentGroup,\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>> {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n\n    return matchResult.pipe(\n      switchMap((result) => {\n        if (!result.matched) {\n          return noMatch(rawSegment);\n        }\n        // If the route has an injector created from providers, we should start using that.\n        injector = route._injector ?? injector;\n        return this.getChildConfig(injector, route, segments).pipe(\n          switchMap(({routes: childConfig}) => {\n            const childInjector = route._loadedInjector ?? injector;\n\n            const {parameters, consumedSegments, remainingSegments} = result;\n            const snapshot = new ActivatedRouteSnapshot(\n              consumedSegments,\n              parameters,\n              Object.freeze({...this.urlTree.queryParams}),\n              this.urlTree.fragment,\n              getData(route),\n              getOutlet(route),\n              route.component ?? route._loadedComponent ?? null,\n              route,\n              getResolve(route),\n            );\n            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n            snapshot.params = Object.freeze(inherited.params);\n            snapshot.data = Object.freeze(inherited.data);\n\n            const {segmentGroup, slicedSegments} = split(\n              rawSegment,\n              consumedSegments,\n              remainingSegments,\n              childConfig,\n            );\n\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(\n                map((children) => {\n                  return new TreeNode(snapshot, children);\n                }),\n              );\n            }\n\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return of(new TreeNode(snapshot, []));\n            }\n\n            const matchedOnOutlet = getOutlet(route) === outlet;\n            // If we matched a config due to empty path match on a different outlet, we need to\n            // continue passing the current outlet for the segment rather than switch to PRIMARY.\n            // Note that we switch to primary when we have a match because outlet configs look like\n            // this: {path: 'a', outlet: 'a', children: [\n            //  {path: 'b', component: B},\n            //  {path: 'c', component: C},\n            // ]}\n            // Notice that the children of the named outlet are configured with the primary outlet\n            return this.processSegment(\n              childInjector,\n              childConfig,\n              segmentGroup,\n              slicedSegments,\n              matchedOnOutlet ? PRIMARY_OUTLET : outlet,\n              true,\n              snapshot,\n            ).pipe(\n              map((child) => {\n                return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n              }),\n            );\n          }),\n        );\n      }),\n    );\n  }\n  private getChildConfig(\n    injector: EnvironmentInjector,\n    route: Route,\n    segments: UrlSegment[],\n  ): Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(\n        mergeMap((shouldLoadResult: boolean) => {\n          if (shouldLoadResult) {\n            return from(this.configLoader.loadChildren(injector, route)).pipe(\n              tap((cfg: LoadedRouterConfig) => {\n                route._loadedRoutes = cfg.routes;\n                route._loadedInjector = cfg.injector;\n              }),\n            );\n          }\n          return canLoadFails(route);\n        }),\n      );\n    }\n\n    return of({routes: [], injector});\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(\n  nodes: Array<TreeNode<ActivatedRouteSnapshot>>,\n): Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode = result.find(\n      (resultNode) => node.value.routeConfig === resultNode.value.routeConfig,\n    );\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n      const c = n.value.url.map((s) => s.toString()).join('/');\n      throw new RuntimeError(\n        RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Two segments cannot have the same outlet name: '${p}' and '${c}'.`,\n      );\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentInjector,\n  EnvironmentProviders,\n  InjectionToken,\n  makeEnvironmentProviders,\n  Type,\n} from '@angular/core';\nimport {MonoTypeOperatorFunction, of} from 'rxjs';\nimport {map, mergeMap, switchMap} from 'rxjs/operators';\n\nimport type {Route} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {recognize as recognizeFn} from '../recognize';\nimport {recognize as recognizeFnRxjs} from '../recognize_rxjs';\nimport type {RouterConfigLoader} from '../router_config_loader';\nimport type {UrlSerializer} from '../url_tree';\n\nconst USE_ASYNC_RECOGNIZE = true;\n\nconst RECOGNIZE_IMPL = new InjectionToken<typeof recognizeFn | typeof recognizeFnRxjs>(\n  'RECOGNIZE_IMPL',\n  {\n    providedIn: 'root',\n    factory: () => {\n      if (!USE_ASYNC_RECOGNIZE) {\n        return recognizeFnRxjs;\n      }\n      return recognizeFn;\n    },\n  },\n);\n\n/**\n * Provides a way to use the synchronous version of the recognize function using rxjs.\n */\nexport function provideSometimesSyncRecognize(): EnvironmentProviders {\n  return makeEnvironmentProviders([{provide: RECOGNIZE_IMPL, useValue: recognizeFnRxjs}]);\n}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Route[],\n  serializer: UrlSerializer,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  abortSignal: AbortSignal,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  // TODO(atscott): Simplify once we do not need to support both forms of recognize\n  const recognizeImpl = injector.get(RECOGNIZE_IMPL);\n  return mergeMap((t) =>\n    of(t).pipe(\n      switchMap((t) =>\n        recognizeImpl(\n          injector,\n          configLoader,\n          rootComponentType,\n          config,\n          t.extractedUrl,\n          serializer,\n          paramsInheritanceStrategy,\n          abortSignal,\n        ),\n      ),\n      map(({state: targetSnapshot, tree: urlAfterRedirects}) => {\n        return {...t, targetSnapshot, urlAfterRedirects};\n      }),\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {defer, EMPTY, from, MonoTypeOperatorFunction, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, map, mergeMap, takeLast, tap} from 'rxjs/operators';\n\nimport {RedirectCommand, ResolveData} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  hasStaticTitle,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {RouteTitleKey} from '../shared';\nimport {getDataKeys, wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {getTokenOrFunctionIdentity} from '../utils/preactivation';\nimport {isEmptyError} from '../utils/type_guards';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport {DefaultUrlSerializer} from '../url_tree';\n\nexport function resolveData(\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      guards: {canActivateChecks},\n    } = t;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n    // preserve the correct order that the resolvers should run in.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n    const routesNeedingDataUpdates = new Set<ActivatedRouteSnapshot>();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      // All children under the route with a resolver to run need to recompute inherited data.\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(\n      concatMap((route) => {\n        if (routesWithResolversToRun.has(route)) {\n          return runResolve(route, targetSnapshot!, paramsInheritanceStrategy, injector);\n        } else {\n          route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n          return of(void 0);\n        }\n      }),\n      tap(() => routesProcessed++),\n      takeLast(1),\n      mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)),\n    );\n  });\n}\n\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot[] {\n  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\n\nfunction runResolve(\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return defer(() => {\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(\n      map((resolvedData: any) => {\n        futureARS._resolvedData = resolvedData;\n        futureARS.data = {...futureARS.data, ...resolvedData};\n        return null;\n      }),\n    );\n  });\n}\n\nfunction resolveNode(\n  resolve: ResolveData,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data: {[k: string | symbol]: any} = {};\n  return from(keys).pipe(\n    mergeMap((key) =>\n      getResolver(resolve[key], futureARS, futureRSS, injector).pipe(\n        first(),\n        tap((value: any) => {\n          if (value instanceof RedirectCommand) {\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n          }\n          data[key] = value;\n        }),\n      ),\n    ),\n    takeLast(1),\n    map(() => data),\n    catchError((e: unknown) => (isEmptyError(e as Error) ? EMPTY : throwError(e))),\n  );\n}\n\nfunction getResolver(\n  injectionToken: ProviderToken<any> | Function,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve\n    ? resolver.resolve(futureARS, futureRSS)\n    : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(\n  next: (x: T) => void | ObservableInput<any>,\n): MonoTypeOperatorFunction<T> {\n  return switchMap((v) => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\nimport {Title} from '@angular/platform-browser';\n\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET, RouteTitleKey} from './shared';\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```ts\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/routing/define-routes#using-titlestrategy-for-page-titles)\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy)})\nexport abstract class TitleStrategy {\n  /** Performs the application title update. */\n  abstract updateTitle(snapshot: RouterStateSnapshot): void;\n\n  /**\n   * @returns The `title` of the deepest primary route.\n   */\n  buildTitle(snapshot: RouterStateSnapshot): string | undefined {\n    let pageTitle: string | undefined;\n    let route: ActivatedRouteSnapshot | undefined = snapshot.root;\n    while (route !== undefined) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n\n  /**\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\n   * `Route.title` property, which can either be a static string or a resolved value.\n   */\n  getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n}\n\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultTitleStrategy extends TitleStrategy {\n  constructor(readonly title: Title) {\n    super();\n  }\n\n  /**\n   * Sets the title of the browser to the given value.\n   *\n   * @param title The `pageTitle` from the deepest primary route.\n   */\n  override updateTitle(snapshot: RouterStateSnapshot): void {\n    const title = this.buildTitle(snapshot);\n    if (title !== undefined) {\n      this.title.setTitle(title);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\nimport {OnSameUrlNavigation, QueryParamsHandling, RedirectCommand} from './models';\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabledNonBlocking' - (default) The initial navigation starts after the\n * root component has been created. The bootstrap is not blocked on the completion of the initial\n * navigation.\n * * 'enabledBlocking' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value should be set in\n * case you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration)\n * for your application.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * @see {@link /api/router/RouterModule#forRoot forRoot}\n *\n * @publicApi\n */\nexport type InitialNavigation = 'disabled' | 'enabledBlocking' | 'enabledNonBlocking';\n\n/**\n * Extra configuration options that can be used with the `withRouterConfig` function.\n *\n * @see [Router configuration options](guide/routing/customizing-route-behavior#router-configuration-options)\n *\n * @publicApi\n */\nexport interface RouterConfigOptions {\n  /**\n   * Configures how the Router attempts to restore state when a navigation is cancelled.\n   *\n   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n   * router before the navigation started. This means that if the URL of the browser is updated\n   * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n   * than trying to restore to the previous location in the session history. This happens most\n   * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n   * buttons.\n   *\n   * 'computed' - Will attempt to return to the same index in the session history that corresponds\n   * to the Angular route when the navigation gets cancelled. For example, if the browser back\n   * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n   * and vice versa.\n   *\n   * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n   * handles a portion of the URL because the history restoration navigates to the previous place in\n   * the browser history rather than simply resetting a portion of the URL.\n   *\n   * The default value is `replace` when not set.\n   *\n   * @see [Handle canceled navigations](guide/routing/customizing-route-behavior#handle-canceled-navigations)\n   *\n   */\n  canceledNavigationResolution?: 'replace' | 'computed';\n\n  /**\n   * Configures the default for handling a navigation request to the current URL.\n   *\n   * If unset, the `Router` will use `'ignore'`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   *\n   * @see [React to same-URL navigations](guide/routing/customizing-route-behavior#react-to-same-url-navigations)\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes.\n   *\n   * By default ('emptyOnly'), a route inherits the parent route's parameters when the route itself\n   * has an empty path (meaning its configured with path: '') or when the parent route doesn't have\n   * any component set.\n   *\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   *\n   * Note that when dealing with matrix parameters, \"parent\" refers to the parent `Route`\n   * config which does not necessarily mean the \"URL segment to the left\". When the `Route` `path`\n   * contains multiple segments, the matrix parameters must appear on the last segment. For example,\n   * matrix parameters for `{path: 'a/b', component: MyComp}` should appear as `a/b;foo=bar` and not\n   * `a;foo=bar/b`.\n   *\n   * @see [Control parameter inheritance](guide/routing/customizing-route-behavior#control-parameter-inheritance)\n   *\n   */\n  paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   *\n   * @see [Decide when the URL updates](guide/routing/customizing-route-behavior#decide-when-the-url-updates)\n   *\n   */\n  urlUpdateStrategy?: 'deferred' | 'eager';\n\n  /**\n   * The default strategy to use for handling query params in `Router.createUrlTree` when one is not provided.\n   *\n   * The `createUrlTree` method is used internally by `Router.navigate` and `RouterLink`.\n   * Note that `QueryParamsHandling` does not apply to `Router.navigateByUrl`.\n   *\n   * When neither the default nor the queryParamsHandling option is specified in the call to `createUrlTree`,\n   * the current parameters will be replaced by new parameters.\n   *\n   * @see {@link Router#createUrlTree}\n   * @see {@link QueryParamsHandling}\n   * \n   * @see [Choose default query parameter handling](guide/routing/customizing-route-behavior#choose-default-query-parameter-handling)\n\n   * \n   */\n  defaultQueryParamsHandling?: QueryParamsHandling;\n\n  /**\n   * When `true`, the `Promise` will instead resolve with `false`, as it does with other failed\n   * navigations (for example, when guards are rejected).\n\n   * Otherwise the `Promise` returned by the Router's navigation with be rejected\n   * if an error occurs.\n   */\n  resolveNavigationPromiseOnError?: boolean;\n}\n\n/**\n * Configuration options for the scrolling feature which can be used with `withInMemoryScrolling`\n * function or `RouterModule.forRoot`.\n *\n * @publicApi\n * @see withInMemoryScrolling\n * @see RouterModule#forRoot\n */\nexport interface InMemoryScrollingOptions {\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   */\n  anchorScrolling?: 'disabled' | 'enabled';\n\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```ts\n   * class AppComponent {\n   *   movieData: any;\n   *\n   *   constructor(private router: Router, private viewportScroller: ViewportScroller,\n   * changeDetectorRef: ChangeDetectorRef) {\n   *   router.events.pipe(filter((event: Event): event is Scroll => event instanceof Scroll)\n   *     ).subscribe(e => {\n   *       fetch('http://example.com/movies.json').then(response => {\n   *         this.movieData = response.json();\n   *         // update the template with the data before restoring scroll\n   *         changeDetectorRef.detectChanges();\n   *\n   *         if (e.position) {\n   *           viewportScroller.scrollToPosition(e.position);\n   *         }\n   *       });\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n}\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see {@link /api/router/routerModule#forRoot forRoot}\n *\n *\n * @publicApi\n */\nexport interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * One of `enabled`, `enabledBlocking`, `enabledNonBlocking` or `disabled`.\n   * When set to `enabled` or `enabledBlocking`, the initial navigation starts before the root\n   * component is created. The bootstrap is blocked until the initial navigation is complete. This\n   * value should be set in case you use [server-side rendering](guide/ssr), but do not enable\n   * [hydration](guide/hydration) for your application. When set to `enabledNonBlocking`,\n   * the initial navigation starts after the root component has been created.\n   * The bootstrap is not blocked on the completion of the initial navigation. When set to\n   * `disabled`, the initial navigation is not performed. The location listener is set up before the\n   * root component gets created. Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * When true, enables binding information from the `Router` state directly to the inputs of the\n   * component in `Route` configurations.\n   */\n  bindToComponentInputs?: boolean;\n\n  /**\n   * When true, enables view transitions in the Router by running the route activation and\n   * deactivation inside of `document.startViewTransition`.\n   *\n   * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n   * @experimental 17.0\n   */\n  enableViewTransitions?: boolean;\n\n  /**\n   * A custom error handler for failed navigations.\n   * If the handler returns a value, the navigation Promise is resolved with this value.\n   * If the handler throws an exception, the navigation Promise is rejected with the exception.\n   *\n   * @see RouterConfigOptions\n   */\n  errorHandler?: (error: any) => RedirectCommand | any;\n\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   */\n  preloadingStrategy?: any;\n\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   */\n  scrollOffset?: [number, number] | (() => [number, number]);\n}\n\n/**\n * A DI token for the router service.\n *\n * @publicApi\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '',\n  {\n    providedIn: 'root',\n    factory: () => ({}),\n  },\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Compiler,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgModuleFactory,\n  runInInjectionContext,\n  Type,\n  ɵresolveComponentResources as resolveComponentResources,\n} from '@angular/core';\n\nimport {DefaultExport, LoadedRouterConfig, Route, Routes} from './models';\nimport {assertStandalone, validateConfig} from './utils/config';\nimport {standardizeConfig} from './components/empty_outlet';\nimport {wrapIntoPromise} from './utils/collection';\n\n/**\n * The DI token for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'ROUTES' : '',\n);\n\n@Injectable({providedIn: 'root'})\nexport class RouterConfigLoader {\n  private componentLoaders = new WeakMap<Route, Promise<Type<unknown>>>();\n  private childrenLoaders = new WeakMap<Route, Promise<LoadedRouterConfig>>();\n  onLoadStartListener?: (r: Route) => void;\n  onLoadEndListener?: (r: Route) => void;\n  private readonly compiler = inject(Compiler);\n\n  async loadComponent(injector: EnvironmentInjector, route: Route): Promise<Type<unknown>> {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route)!;\n    } else if (route._loadedComponent) {\n      return Promise.resolve(route._loadedComponent);\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loader = (async () => {\n      try {\n        const loaded = await wrapIntoPromise(\n          runInInjectionContext(injector, () => route.loadComponent!()),\n        );\n        const component = await maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n\n        if (this.onLoadEndListener) {\n          this.onLoadEndListener(route);\n        }\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          assertStandalone(route.path ?? '', component);\n        route._loadedComponent = component;\n        return component;\n      } finally {\n        this.componentLoaders.delete(route);\n      }\n    })();\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n\n  loadChildren(parentInjector: Injector, route: Route): Promise<LoadedRouterConfig> {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route)!;\n    } else if (route._loadedRoutes) {\n      return Promise.resolve({routes: route._loadedRoutes, injector: route._loadedInjector});\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loader = (async () => {\n      try {\n        const result = await loadChildren(\n          route,\n          this.compiler,\n          parentInjector,\n          this.onLoadEndListener,\n        );\n        route._loadedRoutes = result.routes;\n        route._loadedInjector = result.injector;\n        return result;\n      } finally {\n        this.childrenLoaders.delete(route);\n      }\n    })();\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n}\n\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nexport async function loadChildren(\n  route: Route,\n  compiler: Compiler,\n  parentInjector: Injector,\n  onLoadEndListener?: (r: Route) => void,\n): Promise<LoadedRouterConfig> {\n  const loaded = await wrapIntoPromise(\n    runInInjectionContext(parentInjector, () => route.loadChildren!()),\n  );\n  const t = await maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n\n  let factoryOrRoutes: NgModuleFactory<any> | Routes;\n  if (t instanceof NgModuleFactory || Array.isArray(t)) {\n    factoryOrRoutes = t;\n  } else {\n    factoryOrRoutes = await compiler.compileModuleAsync(t);\n  }\n\n  if (onLoadEndListener) {\n    onLoadEndListener(route);\n  }\n  // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n  // no injector associated with lazy loading a `Route` array.\n  let injector: EnvironmentInjector | undefined;\n  let rawRoutes: Route[];\n  let requireStandaloneComponents = false;\n  if (Array.isArray(factoryOrRoutes)) {\n    rawRoutes = factoryOrRoutes;\n    requireStandaloneComponents = true;\n  } else {\n    injector = factoryOrRoutes.create(parentInjector).injector;\n    // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n    // will get stuck in an infinite loop. The child module's Injector will look to\n    // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n    // for it's parent module instead.\n    rawRoutes = injector.get(ROUTES, [], {optional: true, self: true}).flat();\n  }\n  const routes = rawRoutes.map(standardizeConfig);\n  (typeof ngDevMode === 'undefined' || ngDevMode) &&\n    validateConfig(routes, route.path, requireStandaloneComponents);\n  return {routes, injector};\n}\n\nfunction isWrappedDefaultExport<T>(value: T | DefaultExport<T>): value is DefaultExport<T> {\n  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n  // `default` will be a renamed property.\n  return value && typeof value === 'object' && 'default' in value;\n}\n\nfunction maybeUnwrapDefaultExport<T>(input: T | DefaultExport<T>): T {\n  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n  // subject to property renaming, so we reference it with bracket access.\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n\nfunction maybeResolveResources<T>(value: T): Promise<T> {\n  // In JIT mode we usually resolve the resources of components on bootstrap, however\n  // that won't have happened for lazy-loaded. Attempt to load any pending\n  // resources again here.\n  if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n    return resolveComponentResources(fetch)\n      .catch((error) => {\n        console.error(error);\n        return Promise.resolve();\n      })\n      .then(() => value);\n  }\n\n  return Promise.resolve(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy)})\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean {\n    return true;\n  }\n  extract(url: UrlTree): UrlTree {\n    return url;\n  }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree {\n    return newUrlPart;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {afterNextRender, InjectionToken, Injector, runInInjectionContext} from '@angular/core';\n\nimport {ActivatedRouteSnapshot} from '../router_state';\n\nexport const CREATE_VIEW_TRANSITION = new InjectionToken<typeof createViewTransition>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'view transition helper' : '',\n);\nexport const VIEW_TRANSITION_OPTIONS = new InjectionToken<\n  ViewTransitionsFeatureOptions & {skipNextTransition: boolean}\n>(typeof ngDevMode !== undefined && ngDevMode ? 'view transition options' : '');\n\n/**\n * Options to configure the View Transitions integration in the Router.\n *\n * @developerPreview 20.0\n * @see withViewTransitions\n */\nexport interface ViewTransitionsFeatureOptions {\n  /**\n   * Skips the very first call to `startViewTransition`. This can be useful for disabling the\n   * animation during the application's initial loading phase.\n   */\n  skipInitialTransition?: boolean;\n\n  /**\n   * A function to run after the `ViewTransition` is created.\n   *\n   * This function is run in an injection context and can use `inject`.\n   */\n  onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;\n}\n\n/**\n * The information passed to the `onViewTransitionCreated` function provided in the\n * `withViewTransitions` feature options.\n *\n * @developerPreview 20.0\n */\nexport interface ViewTransitionInfo {\n  /**\n   * The `ViewTransition` returned by the call to `startViewTransition`.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition\n   */\n  transition: ViewTransition;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning from.\n   */\n  from: ActivatedRouteSnapshot;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning to.\n   */\n  to: ActivatedRouteSnapshot;\n}\n\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nexport function createViewTransition(\n  injector: Injector,\n  from: ActivatedRouteSnapshot,\n  to: ActivatedRouteSnapshot,\n): Promise<void> {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n    transitionOptions.skipNextTransition = false;\n    // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n    // until the current event loop exits so we use a promise resolved in a timeout instead\n    // of Promise.resolve().\n    return new Promise((resolve) => setTimeout(resolve));\n  }\n\n  let resolveViewTransitionStarted: () => void;\n  const viewTransitionStarted = new Promise<void>((resolve) => {\n    resolveViewTransitionStarted = resolve;\n  });\n  const transition = document.startViewTransition(() => {\n    resolveViewTransitionStarted();\n    // We don't actually update dom within the transition callback. The resolving of the above\n    // promise unblocks the Router navigation, which synchronously activates and deactivates\n    // routes (the DOM update). This view transition waits for the next change detection to\n    // complete (below), which includes the update phase of the routed components.\n    return createRenderPromise(injector);\n  });\n  transition.ready.catch((error) => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  const {onViewTransitionCreated} = transitionOptions;\n  if (onViewTransitionCreated) {\n    runInInjectionContext(injector, () => onViewTransitionCreated({transition, from, to}));\n  }\n  return viewTransitionStarted;\n}\n\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector: Injector) {\n  return new Promise<void>((resolve) => {\n    // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n    // This ensures any follow-up renders in the microtask queue are completed before the\n    // view transition starts animating.\n    afterNextRender({read: () => setTimeout(resolve)}, {injector});\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  DestroyRef,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  runInInjectionContext,\n  signal,\n  Type,\n  untracked,\n  ɵWritable as Writable,\n} from '@angular/core';\nimport {BehaviorSubject, EMPTY, from, Observable, of, Subject} from 'rxjs';\nimport {catchError, filter, finalize, map, switchMap, take, takeUntil, tap} from 'rxjs/operators';\n\nimport {createRouterState} from './create_router_state';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {\n  BeforeActivateRoutes,\n  Event,\n  GuardsCheckEnd,\n  GuardsCheckStart,\n  IMPERATIVE_NAVIGATION,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  NavigationTrigger,\n  RedirectRequest,\n  ResolveEnd,\n  ResolveStart,\n  RouteConfigLoadEnd,\n  RouteConfigLoadStart,\n  RoutesRecognized,\n} from './events';\nimport {\n  GuardResult,\n  NavigationBehaviorOptions,\n  QueryParamsHandling,\n  RedirectCommand,\n  Route,\n  Routes,\n} from './models';\nimport {\n  isNavigationCancelingError,\n  isRedirectingNavigationCancelingError,\n  redirectingNavigationError,\n} from './navigation_canceling_error';\nimport {activateRoutes} from './operators/activate_routes';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {TitleStrategy} from './page_title_strategy';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  createEmptyState,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport type {Params} from './shared';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {UrlSerializer, UrlTree} from './url_tree';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\nimport {CREATE_VIEW_TRANSITION} from './utils/view_transition';\nimport {getClosestRouteInjector} from './utils/config';\nimport {abortSignalToObservable} from './utils/abort_signal_to_observable';\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#createUrlTree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n *\n * @publicApi\n */\nexport interface UrlCreationOptions {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```ts\n   *  @Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   *\n   * A value of `null` or `undefined` indicates that the navigation commands should be applied\n   * relative to the root.\n   */\n  relativeTo?: ActivatedRoute | null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params | null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `preserve` : Preserve current parameters.\n   * * `merge` : Merge new with current parameters.\n   *\n   * The \"preserve\" option discards any new query params:\n   * ```\n   * // from /view1?page=1 to/view2?page=1\n   * router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n   * });\n   * ```\n   * The \"merge\" option appends new query params to the params from the current URL:\n   * ```\n   * // from /view1?page=1 to/view2?page=1&otherKey=2\n   * router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n   * });\n   * ```\n   * In case of a key collision between current parameters and those in the `queryParams` object,\n   * the new value is used.\n   *\n   */\n  queryParamsHandling?: QueryParamsHandling | null;\n\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see {@link Router#createurltree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n * @see {@link UrlCreationOptions}\n * @see {@link NavigationBehaviorOptions}\n *\n * @publicApi\n */\nexport interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {}\n\nexport type RestoredState = {\n  [k: string]: any;\n  // TODO(#27607): Remove `navigationId` and `ɵrouterPageId` and move to `ng` or `ɵ` namespace.\n  navigationId: number;\n  // The `ɵ` prefix is there to reduce the chance of colliding with any existing user properties on\n  // the history state.\n  ɵrouterPageId?: number;\n};\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport interface Navigation {\n  /**\n   * The unique identifier of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlHandlingStrategy.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * `UrlTree` to use when updating the browser URL for the navigation when `extras.browserUrl` is\n   * defined.\n   * @internal\n   */\n  readonly targetBrowserUrl?: UrlTree | string;\n  /**\n   * TODO(atscott): If we want to make StateManager public, they will need access to this. Note that\n   * it's already eventually exposed through router.routerState.\n   * @internal\n   */\n  targetRouterState?: RouterState;\n  /**\n   * Identifies how this navigation was triggered.\n   */\n  trigger: NavigationTrigger;\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation | null;\n\n  /**\n   * Aborts the navigation if it has not yet been completed or reached the point where routes are being activated.\n   * This function is a no-op if the navigation is beyond the point where it can be aborted.\n   */\n  readonly abort: () => void;\n}\n\nconst noop = () => {};\n\nexport interface NavigationTransition {\n  id: number;\n  currentUrlTree: UrlTree;\n  extractedUrl: UrlTree;\n  currentRawUrl: UrlTree;\n  urlAfterRedirects?: UrlTree;\n  rawUrl: UrlTree;\n  extras: NavigationExtras;\n  resolve: (value: boolean | PromiseLike<boolean>) => void;\n  reject: (reason?: any) => void;\n  promise: Promise<boolean>;\n  source: NavigationTrigger;\n  restoredState: RestoredState | null;\n  currentSnapshot: RouterStateSnapshot;\n  targetSnapshot: RouterStateSnapshot | null;\n  currentRouterState: RouterState;\n  targetRouterState: RouterState | null;\n  guards: Checks;\n  guardsResult: GuardResult | null;\n}\n\n/**\n * The interface from the Router needed by the transitions. Used to avoid a circular dependency on\n * Router. This interface should be whittled down with future refactors. For example, we do not need\n * to get `UrlSerializer` from the Router. We can instead inject it in `NavigationTransitions`\n * directly.\n */\ninterface InternalRouterInterface {\n  config: Routes;\n  navigated: boolean;\n  routeReuseStrategy: RouteReuseStrategy;\n  onSameUrlNavigation: 'reload' | 'ignore';\n}\n\nexport const NAVIGATION_ERROR_HANDLER = new InjectionToken<\n  (error: NavigationError) => unknown | RedirectCommand\n>(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\n\n@Injectable({providedIn: 'root'})\nexport class NavigationTransitions {\n  // Some G3 targets expect the navigation object to be mutated (and not getting a new reference on changes).\n  currentNavigation = signal<Navigation | null>(null, {equal: () => false});\n\n  currentTransition: NavigationTransition | null = null;\n  lastSuccessfulNavigation = signal<Navigation | null>(null);\n  /**\n   * These events are used to communicate back to the Router about the state of the transition. The\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n   * class is not public, this event subject is not publicly exposed.\n   */\n  readonly events = new Subject<Event | BeforeActivateRoutes | RedirectRequest>();\n  /**\n   * Used to abort the current transition with an error.\n   */\n  readonly transitionAbortWithErrorSubject = new Subject<Error>();\n  private readonly configLoader = inject(RouterConfigLoader);\n  private readonly environmentInjector = inject(EnvironmentInjector);\n  private readonly destroyRef = inject(DestroyRef);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly rootContexts = inject(ChildrenOutletContexts);\n  private readonly location = inject(Location);\n  private readonly inputBindingEnabled = inject(INPUT_BINDER, {optional: true}) !== null;\n  private readonly titleStrategy?: TitleStrategy = inject(TitleStrategy);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly paramsInheritanceStrategy =\n    this.options.paramsInheritanceStrategy || 'emptyOnly';\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private readonly createViewTransition = inject(CREATE_VIEW_TRANSITION, {optional: true});\n  private readonly navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {optional: true});\n\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  private transitions?: BehaviorSubject<NavigationTransition | null>;\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation: () => Observable<void> = () => of(void 0);\n  /** @internal */\n  rootComponentType: Type<any> | null = null;\n\n  private destroyed = false;\n\n  constructor() {\n    const onLoadStart = (r: Route) => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  complete() {\n    this.transitions?.complete();\n  }\n\n  handleNavigationRequest(\n    request: Pick<\n      NavigationTransition,\n      | 'source'\n      | 'restoredState'\n      | 'currentUrlTree'\n      | 'currentRawUrl'\n      | 'rawUrl'\n      | 'extras'\n      | 'resolve'\n      | 'reject'\n      | 'promise'\n      | 'currentSnapshot'\n      | 'currentRouterState'\n    >,\n  ) {\n    const id = ++this.navigationId;\n\n    // Navigation can happen as a side effect of template execution, as such we need to untrack signal updates\n    // (Writing to signals is not allowed while Angular renders the template)\n    // TODO: We might want to reconsider allowing navigation as side effect of template execution.\n    untracked(() => {\n      this.transitions?.next({\n        ...request,\n        extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n        targetSnapshot: null,\n        targetRouterState: null,\n        guards: {canActivateChecks: [], canDeactivateChecks: []},\n        guardsResult: null,\n        id,\n      });\n    });\n  }\n\n  setupNavigations(router: InternalRouterInterface): Observable<NavigationTransition> {\n    this.transitions = new BehaviorSubject<NavigationTransition | null>(null);\n    return this.transitions.pipe(\n      filter((t): t is NavigationTransition => t !== null),\n\n      // Using switchMap so we cancel executing navigations when a new one comes in\n      switchMap((overallTransitionState) => {\n        let completedOrAborted = false;\n        const abortController = new AbortController();\n        const shouldContinueNavigation = () => {\n          return !completedOrAborted && this.currentTransition?.id === overallTransitionState.id;\n        };\n        return of(overallTransitionState).pipe(\n          switchMap((t) => {\n            // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n            // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n            // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n            // https://github.com/ReactiveX/rxjs/issues/7455\n            if (this.navigationId > overallTransitionState.id) {\n              const cancellationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancellationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n              return EMPTY;\n            }\n            this.currentTransition = overallTransitionState;\n            const lastSuccessfulNavigation = this.lastSuccessfulNavigation();\n            // Store the Navigation object\n            this.currentNavigation.set({\n              id: t.id,\n              initialUrl: t.rawUrl,\n              extractedUrl: t.extractedUrl,\n              targetBrowserUrl:\n                typeof t.extras.browserUrl === 'string'\n                  ? this.urlSerializer.parse(t.extras.browserUrl)\n                  : t.extras.browserUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: !lastSuccessfulNavigation\n                ? null\n                : {\n                    ...lastSuccessfulNavigation,\n                    previousNavigation: null,\n                  },\n              abort: () => abortController.abort(),\n            });\n            const urlTransition =\n              !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n\n            const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n            if (!urlTransition && onSameUrlNavigation !== 'reload') {\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.rawUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredSameUrlNavigation,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n\n            if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n              return of(t).pipe(\n                // Fire NavigationStart event\n                switchMap((t) => {\n                  this.events.next(\n                    new NavigationStart(\n                      t.id,\n                      this.urlSerializer.serialize(t.extractedUrl),\n                      t.source,\n                      t.restoredState,\n                    ),\n                  );\n                  if (t.id !== this.navigationId) {\n                    return EMPTY;\n                  }\n\n                  // This delay is required to match old behavior that forced\n                  // navigation to always be async\n                  return Promise.resolve(t);\n                }),\n\n                // Recognize\n                recognize(\n                  this.environmentInjector,\n                  this.configLoader,\n                  this.rootComponentType,\n                  router.config,\n                  this.urlSerializer,\n                  this.paramsInheritanceStrategy,\n                  abortController.signal,\n                ),\n\n                // Update URL if in `eager` update mode\n                tap((t) => {\n                  overallTransitionState.targetSnapshot = t.targetSnapshot;\n                  overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                  this.currentNavigation.update((nav) => {\n                    nav!.finalUrl = t.urlAfterRedirects;\n                    return nav;\n                  });\n\n                  // Fire RoutesRecognized\n                  const routesRecognized = new RoutesRecognized(\n                    t.id,\n                    this.urlSerializer.serialize(t.extractedUrl),\n                    this.urlSerializer.serialize(t.urlAfterRedirects!),\n                    t.targetSnapshot!,\n                  );\n                  this.events.next(routesRecognized);\n                }),\n              );\n            } else if (\n              urlTransition &&\n              this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)\n            ) {\n              /* When the current URL shouldn't be processed, but the previous one\n               * was, we handle this \"error condition\" by navigating to the\n               * previously successful URL, but leaving the URL intact.*/\n              const {id, extractedUrl, source, restoredState, extras} = t;\n              const navStart = new NavigationStart(\n                id,\n                this.urlSerializer.serialize(extractedUrl),\n                source,\n                restoredState,\n              );\n              this.events.next(navStart);\n              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n\n              this.currentTransition = overallTransitionState = {\n                ...t,\n                targetSnapshot,\n                urlAfterRedirects: extractedUrl,\n                extras: {...extras, skipLocationChange: false, replaceUrl: false},\n              };\n              this.currentNavigation.update((nav) => {\n                nav!.finalUrl = extractedUrl;\n                return nav;\n              });\n              return of(overallTransitionState);\n            } else {\n              /* When neither the current or previous URL can be processed, do\n               * nothing other than update router's internal reference to the\n               * current \"settled\" URL. This way the next navigation will be coming\n               * from the current URL in the browser.\n               */\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation was ignored because the UrlHandlingStrategy` +\n                    ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredByUrlHandlingStrategy,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n          }),\n\n          map((t) => {\n            const guardsStart = new GuardsCheckStart(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n            );\n            this.events.next(guardsStart);\n            // Note we don't have to check shouldContinueNavigation here because we don't do anything\n            // in the remainder of this operator that has side effects. If `checkGuards` is combined into\n            // this operators, we would need to ensure we check shouldContinueNavigation before running the guards.\n\n            this.currentTransition = overallTransitionState = {\n              ...t,\n              guards: getAllRouteGuards(t.targetSnapshot!, t.currentSnapshot, this.rootContexts),\n            };\n            return overallTransitionState;\n          }),\n\n          checkGuards(this.environmentInjector, (evt: Event) => this.events.next(evt)),\n\n          switchMap((t) => {\n            overallTransitionState.guardsResult = t.guardsResult;\n            if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n            }\n\n            const guardsEnd = new GuardsCheckEnd(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n              !!t.guardsResult,\n            );\n            this.events.next(guardsEnd);\n            if (!shouldContinueNavigation()) {\n              return EMPTY;\n            }\n            if (!t.guardsResult) {\n              this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n              return EMPTY;\n            }\n\n            if (t.guards.canActivateChecks.length === 0) {\n              return of(t);\n            }\n\n            const resolveStart = new ResolveStart(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n            );\n            this.events.next(resolveStart);\n            if (!shouldContinueNavigation()) {\n              return EMPTY;\n            }\n\n            let dataResolved = false;\n            return of(t).pipe(\n              resolveData(this.paramsInheritanceStrategy, this.environmentInjector),\n              tap({\n                next: () => {\n                  dataResolved = true;\n                  const resolveEnd = new ResolveEnd(\n                    t.id,\n                    this.urlSerializer.serialize(t.extractedUrl),\n                    this.urlSerializer.serialize(t.urlAfterRedirects!),\n                    t.targetSnapshot!,\n                  );\n                  this.events.next(resolveEnd);\n                },\n                complete: () => {\n                  if (!dataResolved) {\n                    this.cancelNavigationTransition(\n                      t,\n                      typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `At least one route resolver didn't emit any value.`\n                        : '',\n                      NavigationCancellationCode.NoDataFromResolver,\n                    );\n                  }\n                },\n              }),\n            );\n          }),\n\n          // --- LOAD COMPONENTS ---\n          switchTap((t: NavigationTransition) => {\n            const loadComponents = (route: ActivatedRouteSnapshot): Array<Promise<void>> => {\n              const loaders: Array<Promise<void>> = [];\n              if (route.routeConfig?._loadedComponent) {\n                route.component = route.routeConfig?._loadedComponent;\n              } else if (route.routeConfig?.loadComponent) {\n                const injector = getClosestRouteInjector(route) ?? this.environmentInjector;\n                loaders.push(\n                  this.configLoader\n                    .loadComponent(injector, route.routeConfig)\n                    .then((loadedComponent) => {\n                      route.component = loadedComponent;\n                    }),\n                );\n              }\n              for (const child of route.children) {\n                loaders.push(...loadComponents(child));\n              }\n              return loaders;\n            };\n            const loaders = loadComponents(t.targetSnapshot!.root);\n            return loaders.length === 0 ? of(t) : from(Promise.all(loaders).then(() => t));\n          }),\n\n          switchTap(() => this.afterPreactivation()),\n\n          switchMap(() => {\n            const {currentSnapshot, targetSnapshot} = overallTransitionState;\n            const viewTransitionStarted = this.createViewTransition?.(\n              this.environmentInjector,\n              currentSnapshot.root,\n              targetSnapshot!.root,\n            );\n\n            // If view transitions are enabled, block the navigation until the view\n            // transition callback starts. Otherwise, continue immediately.\n            return viewTransitionStarted\n              ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\n              : of(overallTransitionState);\n          }),\n\n          map((t: NavigationTransition) => {\n            const targetRouterState = createRouterState(\n              router.routeReuseStrategy,\n              t.targetSnapshot!,\n              t.currentRouterState,\n            );\n            this.currentTransition = overallTransitionState = {...t, targetRouterState};\n            this.currentNavigation.update((nav) => {\n              nav!.targetRouterState = targetRouterState;\n              return nav;\n            });\n            return overallTransitionState;\n          }),\n\n          tap(() => {\n            this.events.next(new BeforeActivateRoutes());\n          }),\n\n          activateRoutes(\n            this.rootContexts,\n            router.routeReuseStrategy,\n            (evt: Event) => this.events.next(evt),\n            this.inputBindingEnabled,\n          ),\n\n          // Ensure that if some observable used to drive the transition doesn't\n          // complete, the navigation still finalizes This should never happen, but\n          // this is done as a safety measure to avoid surfacing this error (#49567).\n          take(1),\n\n          takeUntil(\n            abortSignalToObservable(abortController.signal).pipe(\n              // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)\n              filter(() => !completedOrAborted && !overallTransitionState.targetRouterState),\n              tap(() => {\n                this.cancelNavigationTransition(\n                  overallTransitionState,\n                  abortController.signal.reason + '',\n                  NavigationCancellationCode.Aborted,\n                );\n              }),\n            ),\n          ),\n\n          tap({\n            next: (t: NavigationTransition) => {\n              completedOrAborted = true;\n              this.currentNavigation.update((nav) => {\n                (nav as Writable<Navigation>).abort = noop;\n                return nav;\n              });\n              this.lastSuccessfulNavigation.set(untracked(this.currentNavigation));\n              this.events.next(\n                new NavigationEnd(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                ),\n              );\n              this.titleStrategy?.updateTitle(t.targetRouterState!.snapshot);\n              t.resolve(true);\n            },\n            complete: () => {\n              completedOrAborted = true;\n            },\n          }),\n\n          // There used to be a lot more logic happening directly within the\n          // transition Observable. Some of this logic has been refactored out to\n          // other places but there may still be errors that happen there. This gives\n          // us a way to cancel the transition from the outside. This may also be\n          // required in the future to support something like the abort signal of the\n          // Navigation API where the navigation gets aborted from outside the\n          // transition.\n          takeUntil(\n            this.transitionAbortWithErrorSubject.pipe(\n              tap((err) => {\n                throw err;\n              }),\n            ),\n          ),\n\n          finalize(() => {\n            abortController.abort();\n            /* When the navigation stream finishes either through error or success,\n             * we set the `completed` or `errored` flag. However, there are some\n             * situations where we could get here without either of those being set.\n             * For instance, a redirect during NavigationStart. Therefore, this is a\n             * catch-all to make sure the NavigationCancel event is fired when a\n             * navigation gets cancelled but not caught by other means. */\n            if (!completedOrAborted) {\n              const cancelationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancelationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n            }\n            // Only clear current navigation if it is still set to the one that\n            // finalized.\n            if (this.currentTransition?.id === overallTransitionState.id) {\n              this.currentNavigation.set(null);\n              this.currentTransition = null;\n            }\n          }),\n          catchError((e) => {\n            // If the application is already destroyed, the catch block should not\n            // execute anything in practice because other resources have already\n            // been released and destroyed.\n            if (this.destroyed) {\n              overallTransitionState.resolve(false);\n              return EMPTY;\n            }\n\n            completedOrAborted = true;\n            /* This error type is issued during Redirect, and is handled as a\n             * cancellation rather than an error. */\n            if (isNavigationCancelingError(e)) {\n              this.events.next(\n                new NavigationCancel(\n                  overallTransitionState.id,\n                  this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                  e.message,\n                  e.cancellationCode,\n                ),\n              );\n\n              // When redirecting, we need to delay resolving the navigation\n              // promise and push it to the redirect navigation\n              if (!isRedirectingNavigationCancelingError(e)) {\n                overallTransitionState.resolve(false);\n              } else {\n                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n              }\n\n              /* All other errors should reset to the router's internal URL reference\n               * to the pre-error state. */\n            } else {\n              const navigationError = new NavigationError(\n                overallTransitionState.id,\n                this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                e,\n                overallTransitionState.targetSnapshot ?? undefined,\n              );\n\n              try {\n                const navigationErrorHandlerResult = runInInjectionContext(\n                  this.environmentInjector,\n                  () => this.navigationErrorHandler?.(navigationError),\n                );\n\n                if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                  const {message, cancellationCode} = redirectingNavigationError(\n                    this.urlSerializer,\n                    navigationErrorHandlerResult,\n                  );\n                  this.events.next(\n                    new NavigationCancel(\n                      overallTransitionState.id,\n                      this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                      message,\n                      cancellationCode,\n                    ),\n                  );\n                  this.events.next(\n                    new RedirectRequest(\n                      navigationErrorHandlerResult.redirectTo,\n                      navigationErrorHandlerResult.navigationBehaviorOptions,\n                    ),\n                  );\n                } else {\n                  this.events.next(navigationError);\n                  throw e;\n                }\n              } catch (ee) {\n                // TODO(atscott): consider flipping the default behavior of\n                // resolveNavigationPromiseOnError to be `resolve(false)` when\n                // undefined. This is the most sane thing to do given that\n                // applications very rarely handle the promise rejection and, as a\n                // result, would get \"unhandled promise rejection\" console logs.\n                // The vast majority of applications would not be affected by this\n                // change so omitting a migration seems reasonable. Instead,\n                // applications that rely on rejection can specifically opt-in to the\n                // old behavior.\n                if (this.options.resolveNavigationPromiseOnError) {\n                  overallTransitionState.resolve(false);\n                } else {\n                  overallTransitionState.reject(ee);\n                }\n              }\n            }\n\n            return EMPTY;\n          }),\n        );\n        // casting because `pipe` returns observable({}) when called with 8+ arguments\n      }),\n    ) as Observable<NavigationTransition>;\n  }\n\n  private cancelNavigationTransition(\n    t: NavigationTransition,\n    reason: string,\n    code: NavigationCancellationCode,\n  ) {\n    const navCancel = new NavigationCancel(\n      t.id,\n      this.urlSerializer.serialize(t.extractedUrl),\n      reason,\n      code,\n    );\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n\n  /**\n   * @returns Whether we're navigating to somewhere that is not what the Router is\n   * currently set to.\n   */\n  private isUpdatingInternalState() {\n    // TODO(atscott): The serializer should likely be used instead of\n    // `UrlTree.toString()`. Custom serializers are often written to handle\n    // things better than the default one (objects, for example will be\n    // [Object object] with the custom serializer and be \"the same\" when they\n    // aren't).\n    // (Same for isUpdatedBrowserUrl)\n    return (\n      this.currentTransition?.extractedUrl.toString() !==\n      this.currentTransition?.currentUrlTree.toString()\n    );\n  }\n\n  /**\n   * @returns Whether we're updating the browser URL to something new (navigation is going\n   * to somewhere not displayed in the URL bar and we will update the URL\n   * bar if navigation succeeds).\n   */\n  private isUpdatedBrowserUrl() {\n    // The extracted URL is the part of the URL that this application cares about. `extract` may\n    // return only part of the browser URL and that part may have not changed even if some other\n    // portion of the URL did.\n    const currentBrowserUrl = this.urlHandlingStrategy.extract(\n      this.urlSerializer.parse(this.location.path(true)),\n    );\n\n    const currentNavigation = untracked(this.currentNavigation);\n    const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;\n    return (\n      currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\n      !currentNavigation?.extras.skipLocationChange\n    );\n  }\n}\n\nexport function isBrowserTriggeredNavigation(source: NavigationTrigger) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, inject, Injectable} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>;\n  componentRef: ComponentRef<any>;\n  route: TreeNode<ActivatedRoute>;\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy)})\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable} from '@angular/core';\nimport {SubscriptionLike} from 'rxjs';\n\nimport {\n  BeforeActivateRoutes,\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationStart,\n  NavigationTrigger,\n  PrivateRouterEvents,\n  RoutesRecognized,\n} from '../events';\nimport {Navigation, RestoredState} from '../navigation_transition';\nimport {ROUTER_CONFIGURATION} from '../router_config';\nimport {createEmptyState, RouterState} from '../router_state';\nimport {UrlHandlingStrategy} from '../url_handling_strategy';\nimport {UrlSerializer, UrlTree} from '../url_tree';\n\n@Injectable({providedIn: 'root', useFactory: () => inject(HistoryStateManager)})\nexport abstract class StateManager {\n  protected readonly urlSerializer = inject(UrlSerializer);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  protected readonly canceledNavigationResolution =\n    this.options.canceledNavigationResolution || 'replace';\n  protected location = inject(Location);\n  protected urlHandlingStrategy = inject(UrlHandlingStrategy);\n  protected urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n\n  private currentUrlTree = new UrlTree();\n  /**\n   * Returns the currently activated `UrlTree`.\n   *\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`).\n   *\n   * The value is set after finding the route config tree to activate but before activating the\n   * route.\n   */\n  getCurrentUrlTree(): UrlTree {\n    return this.currentUrlTree;\n  }\n\n  private rawUrlTree = this.currentUrlTree;\n  /**\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\n   *\n   * In the life of a navigation transition:\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n   * navigated to.\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n   * to `UrlHandlingStrategy`).\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n   * original raw URL.\n   *\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n   * deviated from the raw `UrlTree`.\n   *\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n   * `UrlHandlingStrategy`.\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\n   * still need to know what the browser's URL is for future navigations.\n   */\n  getRawUrlTree(): UrlTree {\n    return this.rawUrlTree;\n  }\n\n  protected createBrowserPath({finalUrl, initialUrl, targetBrowserUrl}: Navigation): string {\n    const rawUrl =\n      finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl!, initialUrl) : initialUrl;\n    const url = targetBrowserUrl ?? rawUrl;\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    return path;\n  }\n\n  protected commitTransition({targetRouterState, finalUrl, initialUrl}: Navigation): void {\n    // If we are committing the transition after having a final URL and target state, we're updating\n    // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n    // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n    if (finalUrl && targetRouterState) {\n      this.currentUrlTree = finalUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n      this.routerState = targetRouterState;\n    } else {\n      this.rawUrlTree = initialUrl;\n    }\n  }\n\n  private routerState = createEmptyState(null);\n\n  /** Returns the current RouterState. */\n  getRouterState(): RouterState {\n    return this.routerState;\n  }\n\n  private stateMemento = this.createStateMemento();\n\n  protected updateStateMemento(): void {\n    this.stateMemento = this.createStateMemento();\n  }\n\n  private createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState,\n    };\n  }\n\n  protected resetInternalState({finalUrl}: Navigation): void {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree = this.urlHandlingStrategy.merge(\n      this.currentUrlTree,\n      finalUrl ?? this.rawUrlTree,\n    );\n  }\n\n  /** Returns the current state stored by the browser for the current history entry. */\n  abstract restoredState(): RestoredState | null | undefined;\n\n  /**\n   * Registers a listener that is called whenever the current history entry changes by some API\n   * outside the Router. This includes user-activated changes like back buttons and link clicks, but\n   * also includes programmatic APIs called by non-Router JavaScript.\n   */\n  abstract registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike;\n\n  /**\n   * Handles a navigation event sent from the Router. These are typically events that indicate a\n   * navigation has started, progressed, been cancelled, or finished.\n   */\n  abstract handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void;\n}\n\n@Injectable({providedIn: 'root'})\nexport class HistoryStateManager extends StateManager {\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  private lastSuccessfulId: number = -1;\n\n  override restoredState(): RestoredState | null | undefined {\n    return this.location.getState() as RestoredState | null | undefined;\n  }\n\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n  }\n\n  override registerNonRouterCurrentEntryChangeListener(\n    listener: (\n      url: string,\n      state: RestoredState | null | undefined,\n      trigger: NavigationTrigger,\n    ) => void,\n  ): SubscriptionLike {\n    return this.location.subscribe((event) => {\n      if (event['type'] === 'popstate') {\n        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n        // hybrid apps.\n        setTimeout(() => {\n          listener(event['url']!, event.state as RestoredState | null | undefined, 'popstate');\n        });\n      }\n    });\n  }\n\n  override handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void {\n    if (e instanceof NavigationStart) {\n      this.updateStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.commitTransition(currentTransition);\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.commitTransition(currentTransition);\n      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n      }\n    } else if (\n      e instanceof NavigationCancel &&\n      e.code !== NavigationCancellationCode.SupersededByNewNavigation &&\n      e.code !== NavigationCancellationCode.Redirect\n    ) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n\n  private setBrowserUrl(path: string, {extras, id}: Navigation) {\n    const {replaceUrl, state} = extras;\n    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, currentBrowserPageId),\n      };\n      this.location.replaceState(path, '', newState);\n    } else {\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, this.browserPageId + 1),\n      };\n      this.location.go(path, '', newState);\n    }\n  }\n\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  private restoreHistory(navigation: Navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetInternalState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else {\n        // The browser URL and router state was not updated before the navigation cancelled so\n        // there's no restoration needed.\n      }\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetInternalState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n      this.urlSerializer.serialize(this.getRawUrlTree()),\n      '',\n      this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId),\n    );\n  }\n\n  private generateNgRouterState(navigationId: number, routerPageId: number) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {navigationId, ɵrouterPageId: routerPageId};\n    }\n    return {navigationId};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  ɵConsole as Console,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  ɵPendingTasksInternal as PendingTasks,\n  ɵRuntimeError as RuntimeError,\n  Signal,\n  Type,\n  untracked,\n  ɵINTERNAL_APPLICATION_ERROR_HANDLER,\n  ɵformatRuntimeError as formatRuntimeError,\n} from '@angular/core';\nimport {Observable, Subject, Subscription, SubscriptionLike} from 'rxjs';\n\nimport {standardizeConfig} from './components/empty_outlet';\nimport {createSegmentGroupFromRoute, createUrlTreeFromSegmentGroup} from './create_url_tree';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {\n  Event,\n  IMPERATIVE_NAVIGATION,\n  isPublicRouterEvent,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationTrigger,\n  RedirectRequest,\n} from './events';\nimport {NavigationBehaviorOptions, OnSameUrlNavigation, Routes} from './models';\nimport {\n  isBrowserTriggeredNavigation,\n  Navigation,\n  NavigationExtras,\n  NavigationTransitions,\n  RestoredState,\n  UrlCreationOptions,\n} from './navigation_transition';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {Params} from './shared';\nimport {StateManager} from './statemanager/state_manager';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {\n  containsTree,\n  IsActiveMatchOptions,\n  isUrlTree,\n  UrlSegmentGroup,\n  UrlSerializer,\n  UrlTree,\n} from './url_tree';\nimport {validateConfig} from './utils/config';\nimport {afterNextNavigation} from './utils/navigations';\nimport {RouterState} from './router_state';\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nexport const exactMatchOptions: IsActiveMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact',\n};\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nexport const subsetMatchOptions: IsActiveMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset',\n};\n\n/**\n * @description\n *\n * A service that facilitates navigation among views and URL manipulation capabilities.\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\n *\n * @see {@link Route}\n * @see {@link provideRouter}\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Router {\n  private get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  private get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  private disposed = false;\n  private nonRouterCurrentEntryChangeSubscription?: SubscriptionLike;\n\n  private readonly console = inject(Console);\n  private readonly stateManager = inject(StateManager);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly pendingTasks = inject(PendingTasks);\n  private readonly urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  private readonly navigationTransitions = inject(NavigationTransitions);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly location = inject(Location);\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private readonly injector = inject(EnvironmentInjector);\n\n  /**\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\n   * to push events to. The separate field allows us to expose separate types in the public API\n   * (i.e., an Observable rather than the Subject).\n   */\n  private _events = new Subject<Event>();\n  /**\n   * An event stream for routing events.\n   */\n  public get events(): Observable<Event> {\n    // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n    // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n    // allowed/supported but we still have to fix these or file bugs against the teams before making\n    // the change.\n    return this._events;\n  }\n  /**\n   * The current state of routing in this NgModule.\n   */\n  get routerState(): RouterState {\n    return this.stateManager.getRouterState();\n  }\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n\n  /**\n   * A strategy for re-using routes.\n   *\n   * @deprecated Configure using `providers` instead:\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n   */\n  routeReuseStrategy: RouteReuseStrategy = inject(RouteReuseStrategy);\n\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   *\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n   * @see {@link withRouterConfig}\n   * @see {@link provideRouter}\n   * @see {@link RouterModule}\n   */\n  onSameUrlNavigation: OnSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n\n  config: Routes = inject(ROUTES, {optional: true})?.flat() ?? [];\n\n  /**\n   * Indicates whether the application has opted in to binding Router data to component inputs.\n   *\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n   */\n  readonly componentInputBindingEnabled: boolean = !!inject(INPUT_BINDER, {optional: true});\n\n  /**\n   * Signal of the current `Navigation` object when the router is navigating, and `null` when idle.\n   *\n   * Note: The current navigation becomes to null after the NavigationEnd event is emitted.\n   */\n  readonly currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();\n\n  constructor() {\n    this.resetConfig(this.config);\n\n    this.navigationTransitions.setupNavigations(this).subscribe({\n      error: (e) => {\n        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n      },\n    });\n    this.subscribeToNavigationEvents();\n  }\n\n  private eventsSubscription = new Subscription();\n  private subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe((e) => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = untracked(this.navigationTransitions.currentNavigation);\n\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (\n            e instanceof NavigationCancel &&\n            e.code !== NavigationCancellationCode.Redirect &&\n            e.code !== NavigationCancellationCode.SupersededByNewNavigation\n          ) {\n            // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n            // however it's how things were written initially. Investigation would need to be done\n            // to determine if this can be removed.\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const opts = e.navigationBehaviorOptions;\n            const mergedTree = this.urlHandlingStrategy.merge(\n              e.url,\n              currentTransition.currentRawUrl,\n            );\n            const extras = {\n              scroll: currentTransition.extras.scroll,\n              browserUrl: currentTransition.extras.browserUrl,\n              info: currentTransition.extras.info,\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl:\n                currentTransition.extras.replaceUrl ||\n                this.urlUpdateStrategy === 'eager' ||\n                isBrowserTriggeredNavigation(currentTransition.source),\n              // allow developer to override default options with RedirectCommand\n              ...opts,\n            };\n\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise,\n            });\n          }\n        }\n        // Note that it's important to have the Router process the events _before_ the event is\n        // pushed through the public observable. This ensures the correct router state is in place\n        // before applications observe the events.\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e: unknown) {\n        this.navigationTransitions.transitionAbortWithErrorSubject.next(e as Error);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n\n  /** @internal */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(\n        this.location.path(true),\n        IMPERATIVE_NAVIGATION,\n        this.stateManager.restoredState(),\n      );\n    }\n  }\n\n  /**\n   * Sets up the location change listener. This listener detects navigations triggered from outside\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n   * navigation so that the correct events, guards, etc. are triggered.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    this.nonRouterCurrentEntryChangeSubscription ??=\n      this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n        this.navigateToSyncWithBrowser(url, source, state);\n      });\n  }\n\n  /**\n   * Schedules a router navigation to synchronize Router state with the browser state.\n   *\n   * This is done as a response to a popstate event and the initial navigation. These\n   * two scenarios represent times when the browser URL/state has been updated and\n   * the Router needs to respond to ensure its internal state matches.\n   */\n  private navigateToSyncWithBrowser(\n    url: string,\n    source: NavigationTrigger,\n    state: RestoredState | null | undefined,\n  ) {\n    const extras: NavigationExtras = {replaceUrl: true};\n\n    // TODO: restoredState should always include the entire state, regardless\n    // of navigationId. This requires a breaking change to update the type on\n    // NavigationStart’s restoredState, which currently requires navigationId\n    // to always be present. The Router used to only restore history state if\n    // a navigationId was present.\n\n    // The stored navigationId is used by the RouterScroller to retrieve the scroll\n    // position for the page.\n    const restoredState = state?.navigationId ? state : null;\n\n    // Separate to NavigationStart.restoredState, we must also restore the state to\n    // history.state and generate a new navigationId, since it will be overwritten\n    if (state) {\n      const stateCopy = {...state} as Partial<RestoredState>;\n      delete stateCopy.navigationId;\n      delete stateCopy.ɵrouterPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {\n      if (this.disposed) {\n        return;\n      }\n      this.injector.get(ɵINTERNAL_APPLICATION_ERROR_HANDLER)(e);\n    });\n  }\n\n  /** The current URL. */\n  get url(): string {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n\n  /**\n   * Returns the current `Navigation` object when the router is navigating,\n   * and `null` when idle.\n   *\n   * @deprecated 20.2 Use the `currentNavigation` signal instead.\n   */\n  getCurrentNavigation(): Navigation | null {\n    return untracked(this.navigationTransitions.currentNavigation);\n  }\n\n  /**\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\n   *     has not been a successful navigation yet.\n   */\n  get lastSuccessfulNavigation(): Signal<Navigation | null> {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n\n  /**\n   * Resets the route configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n  }\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    this.dispose();\n  }\n\n  /** Disposes of the router. */\n  dispose(): void {\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `router.events`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this._events.unsubscribe();\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n\n  /**\n   * Appends URL segments to the current URL tree to create a new URL tree.\n   *\n   * @param commands An array of URL fragments with which to construct the new URL tree.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n   * property of the options object, if supplied.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   *\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n   * tree should be created relative to the root.\n   * ```\n   */\n  createUrlTree(commands: readonly any[], navigationExtras: UrlCreationOptions = {}): UrlTree {\n    const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} =\n      navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params | null = null;\n    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n      case 'merge':\n        q = {...this.currentUrlTree.queryParams, ...queryParams};\n        break;\n      case 'preserve':\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n\n    let relativeToUrlSegmentGroup: UrlSegmentGroup | undefined;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e: unknown) {\n      // This is strictly for backwards compatibility with tests that create\n      // invalid `ActivatedRoute` mocks.\n      // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n      // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n      // the moment.\n      if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n        // Navigations that were absolute in the old way of creating UrlTrees\n        // would still work because they wouldn't attempt to match the\n        // segments in the `ActivatedRoute` to the `currentUrlTree` but\n        // instead just replace the root segment with the navigation result.\n        // Non-absolute navigations would fail to apply the commands because\n        // the logic could not find the segment to replace (so they'd act like there were no\n        // commands).\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(\n      relativeToUrlSegmentGroup,\n      commands,\n      q,\n      f ?? null,\n      this.urlSerializer,\n    );\n  }\n\n  /**\n   * Navigates to a view using an absolute route path.\n   *\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\n   *     current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to an absolute path.\n   *\n   * ```ts\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigateByUrl(\n    url: string | UrlTree,\n    extras: NavigationBehaviorOptions = {\n      skipLocationChange: false,\n    },\n  ): Promise<boolean> {\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * @param commands An array of URL fragments with which to construct the target URL.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n   * of the options object, if supplied.\n   * @param extras An options object that determines how the URL should be constructed or\n   *     interpreted.\n   *\n   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n   * not `true`.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to a dynamic route path relative to the current URL.\n   *\n   * ```ts\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL, overriding the default behavior\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigate(\n    commands: readonly any[],\n    extras: NavigationExtras = {skipLocationChange: false},\n  ): Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string {\n    return this.urlSerializer.serialize(url);\n  }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch (e) {\n      this.console.warn(\n        formatRuntimeError(\n          RuntimeErrorCode.ERROR_PARSING_URL,\n          ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. \\n` + e,\n        ),\n      );\n      return this.urlSerializer.parse('/');\n    }\n  }\n\n  /**\n   * Returns whether the url is activated.\n   *\n   * @deprecated\n   * Use `IsActiveMatchOptions` instead.\n   *\n   * - The equivalent `IsActiveMatchOptions` for `true` is\n   * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n   * - The equivalent for `false` is\n   * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n   */\n  isActive(url: string | UrlTree, exact: boolean): boolean;\n  /**\n   * Returns whether the url is activated.\n   */\n  isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n  /** @internal */\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean;\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean {\n    let options: IsActiveMatchOptions;\n    if (matchOptions === true) {\n      options = {...exactMatchOptions};\n    } else if (matchOptions === false) {\n      options = {...subsetMatchOptions};\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.entries(params).reduce((result: Params, [key, value]: [string, any]) => {\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private scheduleNavigation(\n    rawUrl: UrlTree,\n    source: NavigationTrigger,\n    restoredState: RestoredState | null,\n    extras: NavigationExtras,\n    priorPromise?: {\n      resolve: (result: boolean | PromiseLike<boolean>) => void;\n      reject: (reason?: any) => void;\n      promise: Promise<boolean>;\n    },\n  ): Promise<boolean> {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n\n    let resolve: (result: boolean | PromiseLike<boolean>) => void;\n    let reject: (reason?: any) => void;\n    let promise: Promise<boolean>;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise<boolean>((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n\n    // Indicate that the navigation is happening.\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      // Remove pending task in a microtask to allow for cancelled\n      // initial navigations and redirects within the same task.\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve: resolve!,\n      reject: reject!,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState,\n    });\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => {\n      return Promise.reject(e);\n    });\n  }\n}\n\nfunction validateCommands(commands: readonly string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NULLISH_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `The requested path contains ${cmd} segment at index ${i}`,\n      );\n    }\n  }\n}\n"],"names":["RouteTitleKey","Symbol","ParamsAsMap","params","Object","prototype","hasOwnProperty","call","name","v","has","Array","isArray","keys","part","isParameter","segment","path","i","a","length","shallowEqual","b","undefined","k2","getDataKeys","k1","key","equalArraysOrString","obj","getOwnPropertySymbols","aSorted","every","val","index","bSorted","last","isPromise","value","from","Promise","resolve","containsSegmentGroup","paramCompareMap","equalParams","ignored","containsTree","container","containee","options","pathCompareMap","paths","root","matrixParams","queryParams","fragment","containsSegmentGroupHelper","containeePaths","segments","current","slice","hasChildren","matrixParamsMatch","equalPath","c","children","containerPaths","containeeSegment","parameters","UrlSegmentGroup","ngDevMode","RuntimeError","queryParamMap","convertToParamMap","_queryParamMap","toString","values","forEach","parent","serializePaths","parameterMap","_parameterMap","serializePath","equalSegments","as","bs","mapChildrenIntoArray","fn","entries","childOutlet","child","PRIMARY_OUTLET","res","concat","serialize","tree","query","serializeQueryParams","encodeUriFragment","DEFAULT_SERIALIZER","DefaultUrlSerializer","map","p","join","serializeSegment","primary","k","push","encodeURIComponent","s","encodeUriQuery","encodeURI","decodeQuery","decode","replace","encodeUriSegment","serializeMatrixParams","filter","strParams","matchSegments","str","match","SEGMENT_RE","matchMatrixKeySegments","MATRIX_PARAM_SEGMENT_RE","QUERY_PARAM_RE","QUERY_PARAM_VALUE_RE","remaining","constructor","url","parseRootSegment","peekStartsWith","parseChildren","parseQueryParam","consumeOptional","parseFragment","decodeURIComponent","parseSegment","capture","UrlSegment","parseMatrixParams","parseParam","createSegmentGroupFromRouteRecursive","currentRoute","childOutlets","childSnapshot","segmentGroup","route","targetGroup","rootSegmentGroup","createUrlTreeFromSegmentGroup","relativeTo","commands","urlSerializer","nav","computeNavigation","toRoot","position","findStartingPositionForTargetGroup","processChildren","updateSegmentGroup","newSegmentGroup","command","outlets","segmentPath","isCommandWithOutlets","parse","oldRoot","oldSegmentGroup","qp","normalizeQueryParams","rootCandidate","replaceSegment","UrlTree","newRoot","newSegment","isAbsolute","numberOfDoubleDots","isMatrixParams","cmdWithOutlet","find","Navigation","cmd","split","cmdIdx","urlPart","partIndex","target","Position","NaN","createPositionApplyingDoubleDots","group","g","dd","ci","getOutlets","startIndex","updateSegmentGroupChildren","m","pathIndex","slicedCommands","createNewSegmentGroup","numberOfChildren","childrenOfEmptyChild","outlet","IMPERATIVE_NAVIGATION","EventType","id","navigationTrigger","restoredState","urlAfterRedirects","NavigationCancellationCode","NavigationSkippedCode","reason","error","state","GuardsCheckStart","RouterEvent","shouldActivate","ResolveEnd","RouteConfigLoadStart","RouteConfigLoadEnd","snapshot","routeConfig","routerEvent","scrollBehavior","anchor","pos","BeforeActivateRoutes","navigationBehaviorOptions","isPublicRouterEvent","e","RedirectRequest","stringifyEvent","type","ActivationStart","ChildActivationEnd","isNgModule","component","fullPath","isStandalone","validateNode","requireStandaloneComponents","loadComponent","loadChildren","redirectTo","canMatch","charAt","pathMatch","exp","OutletContext","getClosestRouteInjector","rootInjector","ChildrenOutletContexts","context","getOrCreateContext","childName","onChildOutletDestroyed","onOutletDeactivated","contexts","getContext","Tree","_root","pathFromRoot","t","n","findNode","findPath","node","TreeNode","createEmptyStateSnapshot","rootComponent","emptyParams","BehaviorSubject","emptyData","emptyQueryParams","activated","ActivatedRoute","emptyUrl","RouterState","_futureSnapshot","_routerState","urlSubject","paramsSubject","fragmentSubject","dataSubject","futureSnapshot","queryParamsSubject","title","pipe","d","of","data","paramMap","getInherited","paramsInheritanceStrategy","inherited","_resolvedData","hasStaticTitle","_resolve","_paramMap","matched","setRouterState","serializeNode","_activatedRoute","activateEvents","EventEmitter","deactivateEvents","attachEvents","parentContexts","inject","location","ViewContainerRef","ngOnChanges","changes","inputBinder","unsubscribeFromRouteData","isTrackedInParentContexts","outletName","initializeOutletWithName","onChildOutletCreated","attachRef","attach","activatedRouteData","ref","deactivate","Output","i0","Input","args","isSignal","alias","required","outletData","template","standardizeConfig","r","ɵEmptyOutletComponent","createNode","routeReuseStrategy","curr","prevState","shouldReuseRoute","createOrReuseChildren","shouldAttach","retrieve","detachedRouteHandle","createActivatedRoute","navigationCancelingError","Redirect","ActivateRoutes","inputBindingEnabled","futureState","currState","forwardEvent","futureRoot","currRoot","deactivateChildRoutes","advanceActivatedRoute","activateChildRoutes","futureNode","currNode","nodeChildrenAsMap","futureChild","deactivateRoutes","parentContext","future","deactivateRouteAndItsChildren","shouldDetach","detachAndStoreRouteSubtree","deactivateRouteAndOutlet","treeNode","componentRef","detach","store","activateRoutes","ActivationEnd","CanDeactivate","getAllRouteGuards","getChildRouteGuards","getCanActivateChild","canActivateChild","guards","getTokenOrFunctionIdentity","tokenOrFunction","injector","NOT_FOUND","result","get","isInjectable","futurePath","checks","getRouteGuards","prevChildren","canActivateChecks","shouldRun","shouldRunGuardsAndResolvers","runGuardsAndResolvers","CanActivate","isActivated","canDeactivateChecks","guard","isFunction","canLoad","canActivate","isCanActivateChild","switchMap","obs","combineLatest","o","take","startWith","INITIAL_VALUE","results","isRedirect","abortSignalToObservable","signal","aborted","subscriber","next","complete","addEventListener","handler","removeEventListener","takeUntilAbort","checkGuards","mergeMap","targetSnapshot","currentSnapshot","guardsResult","canDeactivate","runCanDeactivateChecks","check","runCanDeactivate","currRSS","futureRSS","first","runCanActivateChecks","fireChildActivationStart","fireActivationStart","runCanActivateChild","runCanActivate","futureARS","NoMatch","Error","setPrototypeOf","AbsoluteRedirect","urlTree","namedOutletsRedirect","canLoadFails","ApplyRedirects","lineralizeSegments","redirect","getRedirectResult","newTree","applyRedirectCreateUrlTree","posParams","createQueryParams","redirectToParams","actualParams","copySourceValue","sourceName","substring","noMatch","consumedSegments","remainingSegments","positionalParamSegments","matchWithChecks","abortSignal","getOrCreateRouteInjectorIfNeeded","runCanMatchGuards","matcher","defaultUrlMatcher","consumed","slicedSegments","containsEmptyPathMatchesWithNamedOutlets","config","containsEmptyPathMatches","NoLeftoversInUrl","configLoader","applyRedirects","absoluteRedirectCount","allowRedirects","rootComponentType","noMatchError","recognize","rootSnapshot","rootNode","routeState","ActivatedRouteSnapshot","freeze","processSegmentGroup","parentRoute","processSegment","unshift","sortedConfig","sortByMatchingOutlets","outletChildren","mergeEmptyPathMatches","sortActivatedRouteSnapshots","mergedChildren","routes","processSegmentAgainstRoute","_injector","isEmptyError","getOutlet","emptyPathMatch","rawSegment","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","MAX_ALLOWED_REDIRECTS","throwError","createSegmentGroup","RouterStateSnapshot","createUrlTreeFromSnapshot","concatMap","catchError","x","noLeftoversInUrl","RECOGNIZE_IMPL","InjectionToken","factory","resolveData","routesWithResolversToRun","routesNeedingDataUpdates","Set","newRoute","flattenRouteTree","runResolve","tap","routesProcessed","takeLast","_","size","EMPTY","descendants","flat","defer","resolveNode","resolvedData","switchTap","pageTitle","ɵfac","ɵɵngDeclareFactory","minVersion","version","ngImport","TitleStrategy","deps","ɵɵFactoryTarget","Injectable","decorators","providedIn","useFactory","DefaultTitleStrategy","updateTitle","buildTitle","ROUTER_CONFIGURATION","componentLoaders","_loadedComponent","onLoadStartListener","loader","loaded","wrapIntoPromise","onLoadEndListener","assertStandalone","set","childrenLoaders","_loadedRoutes","RouterConfigLoader","ɵɵngDeclareInjectable","factoryOrRoutes","compiler","compileModuleAsync","rawRoutes","create","parentInjector","shouldProcessUrl","createViewTransition","to","noop","NAVIGATION_ERROR_HANDLER","NavigationTransitions","debugName","equal","currentTransition","DestroyRef","Location","optional","titleStrategy","urlHandlingStrategy","UrlHandlingStrategy","CREATE_VIEW_TRANSITION","navigationErrorHandler","navigationId","hasRequestedNavigation","transitions","afterPreactivation","onLoadEnd","events","onLoadStart","destroyRef","onDestroy","destroyed","handleNavigationRequest","request","extractedUrl","extract","rawUrl","targetRouterState","setupNavigations","router","overallTransitionState","shouldContinueNavigation","cancellationReason","lastSuccessfulNavigation","RouteReuseStrategy","DefaultRouteReuseStrategy","StateManager","UrlSerializer","canceledNavigationResolution","commitTransition","finalUrl","initialUrl","currentUrlTree","routerState","createEmptyState","getRouterState","createStateMemento","resetInternalState","stateMemento","rawUrlTree","merge","HistoryStateManager","browserPageId","registerNonRouterCurrentEntryChangeListener","listener","subscribe","event","setTimeout","handleRouterEvent","NavigationStart","RoutesRecognized","urlUpdateStrategy","extras","skipLocationChange","setBrowserUrl","createBrowserPath","SupersededByNewNavigation","NavigationError","NavigationEnd","lastSuccessfulId","currentPageId","replaceUrl","isCurrentPathEqualTo","currentBrowserPageId","generateNgRouterState","exactMatchOptions","disposed","nonRouterCurrentEntryChangeSubscription","Console","EnvironmentInjector","_events","Subject","stateManager","INPUT_BINDER","navigationTransitions","currentNavigation","asReadonly","Subscription","subscribeToNavigationEvents","untracked","NavigationCancel","code","navigated","opts","mergedTree","currentRawUrl","scroll","browserUrl","info","scheduleNavigation","reject","promise","transitionAbortWithErrorSubject","add","subscription","resetRootComponentType","navigateToSyncWithBrowser","stateCopy","ɵrouterPageId","dispose","unsubscribe","relativeToSnapshot","relativeToUrlSegmentGroup","q","f"],"mappings":"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"}