{"version":3,"file":"collection.js","sourceRoot":"","sources":["../../../../../../packages/router/src/utils/collection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatAll, every, last as lastValue, map, mergeAll} from 'rxjs/operators';\n\nimport {PRIMARY_OUTLET} from '../shared';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(a: {[x: string]: any}, b: {[x: string]: any}): boolean {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) {\n    return false;\n  }\n  let key: string;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\n/**\n * Verifys all booleans in an array are `true`.\n */\nexport function and(bools: boolean[]): boolean {\n  return !bools.some(v => !v);\n}\n\nexport function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: string) => void): void {\n  for (const prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nexport function waitForMap<A, B>(\n    obj: {[k: string]: A}, fn: (k: string, a: A) => Observable<B>): Observable<{[k: string]: B}> {\n  if (Object.keys(obj).length === 0) {\n    return of ({});\n  }\n\n  const waitHead: Observable<B>[] = [];\n  const waitTail: Observable<B>[] = [];\n  const res: {[k: string]: B} = {};\n\n  forEach(obj, (a: A, k: string) => {\n    const mapped = fn(k, a).pipe(map((r: B) => res[k] = r));\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  });\n\n  // Closure compiler has problem with using spread operator here. So just using Array.concat.\n  return of .apply(null, waitHead.concat(waitTail)).pipe(concatAll(), lastValue(), map(() => res));\n}\n\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n */\nexport function andObservables(observables: Observable<Observable<any>>): Observable<boolean> {\n  return observables.pipe(mergeAll(), every((result: any) => result === true));\n}\n\nexport function wrapIntoObservable<T>(value: T | NgModuleFactory<T>| Promise<T>| Observable<T>):\n    Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of (value as T);\n}\n"]}