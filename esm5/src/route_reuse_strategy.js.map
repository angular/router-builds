{"version":3,"file":"route_reuse_strategy.js","sourceRoot":"","sources":["../../../../../packages/router/src/route_reuse_strategy.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAwCA;;;;;;;;AAAA;;;6BAxCA;IA2DC,CAAA;;;;;;;;;AAnBD,8BAmBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKD;;;AAAA;;;;;;;IACE,gDAAY;;;;IAAZ,UAAa,KAA6B,IAAa,MAAM,CAAC,KAAK,CAAC,EAAE;;;;;;IACtE,yCAAK;;;;;IAAL,UAAM,KAA6B,EAAE,YAAiC,KAAU;;;;;IAChF,gDAAY;;;;IAAZ,UAAa,KAA6B,IAAa,MAAM,CAAC,KAAK,CAAC,EAAE;;;;;IACtE,4CAAQ;;;;IAAR,UAAS,KAA6B,IAA8B,MAAM,CAAC,IAAI,CAAC,EAAE;;;;;;IAClF,oDAAgB;;;;;IAAhB,UAAiB,MAA8B,EAAE,IAA4B;QAC3E,MAAM,CAAC,MAAM,CAAC,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC;KAChD;oCAvEH;IAwEC,CAAA;;;;AARD,qCAQC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @experimental\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>,\n  componentRef: ComponentRef<any>,\n  route: TreeNode<ActivatedRoute>,\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @experimental\n */\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle|null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nexport class DefaultRouteReuseStrategy implements RouteReuseStrategy {\n  shouldDetach(route: ActivatedRouteSnapshot): boolean { return false; }\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n  shouldAttach(route: ActivatedRouteSnapshot): boolean { return false; }\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null { return null; }\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n"]}