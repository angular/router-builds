/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __read, __spread } from "tslib";
import { combineLatest } from 'rxjs';
import { filter, map, scan, startWith, switchMap, take } from 'rxjs/operators';
import { isUrlTree } from '../utils/type_guards';
var INITIAL_VALUE = Symbol('INITIAL_VALUE');
export function prioritizedGuardValue() {
    return switchMap(function (obs) {
        return combineLatest.apply(void 0, __spread(obs.map(function (o) { return o.pipe(take(1), startWith(INITIAL_VALUE)); }))).pipe(scan(function (acc, list) {
            var isPending = false;
            return list.reduce(function (innerAcc, val, i) {
                if (innerAcc !== INITIAL_VALUE)
                    return innerAcc;
                // Toggle pending flag if any values haven't been set yet
                if (val === INITIAL_VALUE)
                    isPending = true;
                // Any other return values are only valid if we haven't yet hit a pending
                // call. This guarantees that in the case of a guard at the bottom of the
                // tree that returns a redirect, we will wait for the higher priority
                // guard at the top to finish before performing the redirect.
                if (!isPending) {
                    // Early return when we hit a `false` value as that should always
                    // cancel navigation
                    if (val === false)
                        return val;
                    if (i === list.length - 1 || isUrlTree(val)) {
                        return val;
                    }
                }
                return innerAcc;
            }, acc);
        }, INITIAL_VALUE), filter(function (item) { return item !== INITIAL_VALUE; }), map(function (item) { return isUrlTree(item) ? item : item === true; }), //
        take(1));
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpb3JpdGl6ZWRfZ3VhcmRfdmFsdWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9yb3V0ZXIvc3JjL29wZXJhdG9ycy9wcmlvcml0aXplZF9ndWFyZF92YWx1ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7O0FBRUgsT0FBTyxFQUFDLGFBQWEsRUFBK0IsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFHN0UsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRS9DLElBQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUc5QyxNQUFNLFVBQVUscUJBQXFCO0lBRW5DLE9BQU8sU0FBUyxDQUFDLFVBQUEsR0FBRztRQUNsQixPQUFPLGFBQWEsd0JBQ04sR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxhQUErQixDQUFDLENBQUMsRUFBM0QsQ0FBMkQsQ0FBQyxHQUMzRSxJQUFJLENBQ0QsSUFBSSxDQUNBLFVBQUMsR0FBbUIsRUFBRSxJQUFzQjtZQUMxQyxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFTO2dCQUMxQyxJQUFJLFFBQVEsS0FBSyxhQUFhO29CQUFFLE9BQU8sUUFBUSxDQUFDO2dCQUVoRCx5REFBeUQ7Z0JBQ3pELElBQUksR0FBRyxLQUFLLGFBQWE7b0JBQUUsU0FBUyxHQUFHLElBQUksQ0FBQztnQkFFNUMseUVBQXlFO2dCQUN6RSx5RUFBeUU7Z0JBQ3pFLHFFQUFxRTtnQkFDckUsNkRBQTZEO2dCQUM3RCxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNkLGlFQUFpRTtvQkFDakUsb0JBQW9CO29CQUNwQixJQUFJLEdBQUcsS0FBSyxLQUFLO3dCQUFFLE9BQU8sR0FBRyxDQUFDO29CQUU5QixJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7d0JBQzNDLE9BQU8sR0FBRyxDQUFDO3FCQUNaO2lCQUNGO2dCQUVELE9BQU8sUUFBUSxDQUFDO1lBQ2xCLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNWLENBQUMsRUFDRCxhQUFhLENBQUMsRUFDbEIsTUFBTSxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxLQUFLLGFBQWEsRUFBdEIsQ0FBc0IsQ0FBQyxFQUN0QyxHQUFHLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksRUFBdEMsQ0FBc0MsQ0FBQyxFQUFHLEVBQUU7UUFDeEQsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFnQyxDQUFDO0lBQ3pELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZmlsdGVyLCBtYXAsIHNjYW4sIHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7VXJsVHJlZX0gZnJvbSAnLi4vdXJsX3RyZWUnO1xuaW1wb3J0IHtpc1VybFRyZWV9IGZyb20gJy4uL3V0aWxzL3R5cGVfZ3VhcmRzJztcblxuY29uc3QgSU5JVElBTF9WQUxVRSA9IFN5bWJvbCgnSU5JVElBTF9WQUxVRScpO1xuZGVjbGFyZSB0eXBlIElOVEVSSU1fVkFMVUVTID0gdHlwZW9mIElOSVRJQUxfVkFMVUUgfCBib29sZWFuIHwgVXJsVHJlZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByaW9yaXRpemVkR3VhcmRWYWx1ZSgpOlxuICAgIE9wZXJhdG9yRnVuY3Rpb248T2JzZXJ2YWJsZTxib29sZWFufFVybFRyZWU+W10sIGJvb2xlYW58VXJsVHJlZT4ge1xuICByZXR1cm4gc3dpdGNoTWFwKG9icyA9PiB7XG4gICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgICAgICAuLi5vYnMubWFwKG8gPT4gby5waXBlKHRha2UoMSksIHN0YXJ0V2l0aChJTklUSUFMX1ZBTFVFIGFzIElOVEVSSU1fVkFMVUVTKSkpKVxuICAgICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgc2NhbihcbiAgICAgICAgICAgICAgICAgICAgICAgKGFjYzogSU5URVJJTV9WQUxVRVMsIGxpc3Q6IElOVEVSSU1fVkFMVUVTW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKChpbm5lckFjYywgdmFsLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckFjYyAhPT0gSU5JVElBTF9WQUxVRSkgcmV0dXJuIGlubmVyQWNjO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2dnbGUgcGVuZGluZyBmbGFnIGlmIGFueSB2YWx1ZXMgaGF2ZW4ndCBiZWVuIHNldCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IElOSVRJQUxfVkFMVUUpIGlzUGVuZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueSBvdGhlciByZXR1cm4gdmFsdWVzIGFyZSBvbmx5IHZhbGlkIGlmIHdlIGhhdmVuJ3QgeWV0IGhpdCBhIHBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwuIFRoaXMgZ3VhcmFudGVlcyB0aGF0IGluIHRoZSBjYXNlIG9mIGEgZ3VhcmQgYXQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWUgdGhhdCByZXR1cm5zIGEgcmVkaXJlY3QsIHdlIHdpbGwgd2FpdCBmb3IgdGhlIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3VhcmQgYXQgdGhlIHRvcCB0byBmaW5pc2ggYmVmb3JlIHBlcmZvcm1pbmcgdGhlIHJlZGlyZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuIHdoZW4gd2UgaGl0IGEgYGZhbHNlYCB2YWx1ZSBhcyB0aGF0IHNob3VsZCBhbHdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpIHJldHVybiB2YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGxpc3QubGVuZ3RoIC0gMSB8fCBpc1VybFRyZWUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyQWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFjYyk7XG4gICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgIElOSVRJQUxfVkFMVUUpLFxuICAgICAgICAgICAgICAgICAgIGZpbHRlcihpdGVtID0+IGl0ZW0gIT09IElOSVRJQUxfVkFMVUUpLFxuICAgICAgICAgICAgICAgICAgIG1hcChpdGVtID0+IGlzVXJsVHJlZShpdGVtKSA/IGl0ZW0gOiBpdGVtID09PSB0cnVlKSwgIC8vXG4gICAgICAgICAgICAgICAgICAgdGFrZSgxKSkgYXMgT2JzZXJ2YWJsZTxib29sZWFufFVybFRyZWU+O1xuICB9KTtcbn1cbiJdfQ==