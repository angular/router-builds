{"version":3,"file":"events.js","sourceRoot":"","sources":["../../../../../packages/router/src/events.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './config';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n\n/**\n * @description\n *\n * Identifies the trigger of the navigation.\n *\n * * 'imperative'--triggered by `router.navigateByUrl` or `router.navigate`.\n * * 'popstate'--triggered by a popstate event\n * * 'hashchange'--triggered by a hashchange event\n *\n * @experimental\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\n\n/**\n * @description\n *\n * Base for events the Router goes through, as opposed to events tied to a specific\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\n *\n * Example:\n *\n * ```\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.filter(e => e instanceof RouterEvent).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @experimental\n */\nexport class RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      public id: number,\n      /** @docsNotRequired */\n      public url: string) {}\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation starts.\n *\n *\n */\nexport class NavigationStart extends RouterEvent {\n  /**\n   * Identifies the trigger of the navigation.\n   *\n   * * 'imperative'--triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--triggered by a popstate event\n   * * 'hashchange'--triggered by a hashchange event\n   */\n  navigationTrigger?: 'imperative'|'popstate'|'hashchange';\n\n  /**\n   * This contains the navigation id that pushed the history record that the router navigates\n   * back to. This is not null only when the navigation is triggered by a popstate event.\n   *\n   * The router assigns a navigationId to every router transition/navigation. Even when the user\n   * clicks on the back button in the browser, a new navigation id will be created. So from\n   * the perspective of the router, the router never \"goes back\". By using the `restoredState`\n   * and its navigationId, you can implement behavior that differentiates between creating new\n   * states\n   * and popstate events. In the latter case you can restore some remembered state (e.g., scroll\n   * position).\n   */\n  restoredState?: {navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: 'imperative'|'popstate'|'hashchange' = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationStart(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation ends successfully.\n *\n *\n */\nexport class NavigationEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation is canceled.\n *\n *\n */\nexport class NavigationCancel extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public reason: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationCancel(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a navigation fails due to an unexpected error.\n *\n *\n */\nexport class NavigationError extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when routes are recognized.\n *\n *\n */\nexport class RoutesRecognized extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of the Guard phase of routing.\n *\n * @experimental\n */\nexport class GuardsCheckStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the end of the Guard phase of routing.\n *\n * @experimental\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of the Resolve phase of routing. The timing of this\n * event may change, thus it's experimental. In the current iteration it will run\n * in the \"resolve\" phase whether there's things to resolve or not. In the future this\n * behavior may change to only run when there are things to be resolved.\n *\n * @experimental\n */\nexport class ResolveStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the end of the Resolve phase of routing. See note on\n * `ResolveStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ResolveEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * @description\n *\n * Represents an event triggered before lazy loading a route config.\n *\n * @experimental\n */\nexport class RouteConfigLoadStart {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadStart(path: ${this.route.path})`; }\n}\n\n/**\n * @description\n *\n * Represents an event triggered when a route has been lazy loaded.\n *\n * @experimental\n */\nexport class RouteConfigLoadEnd {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadEnd(path: ${this.route.path})`; }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationEnd` for use of this experimental API.\n *\n * @experimental\n */\nexport class ChildActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ChildActivationStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ChildActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationEnd` for use of this experimental API.\n *\n * @experimental\n */\nexport class ActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the start of end of the Resolve phase of routing. See note on\n * `ActivationStart` for use of this experimental API.\n *\n * @experimental\n */\nexport class ActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents a router event, allowing you to track the lifecycle of the router.\n *\n * The sequence of router events is:\n *\n * - `NavigationStart`,\n * - `RouteConfigLoadStart`,\n * - `RouteConfigLoadEnd`,\n * - `RoutesRecognized`,\n * - `GuardsCheckStart`,\n * - `ChildActivationStart`,\n * - `ActivationStart`,\n * - `GuardsCheckEnd`,\n * - `ResolveStart`,\n * - `ResolveEnd`,\n * - `ActivationEnd`\n * - `ChildActivationEnd`\n * - `NavigationEnd`,\n * - `NavigationCancel`,\n * - `NavigationError`\n *\n *\n */\nexport type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart |\n    ChildActivationEnd | ActivationStart | ActivationEnd;\n"]}