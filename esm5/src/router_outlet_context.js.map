{"version":3,"file":"router_outlet_context.js","sourceRoot":"","sources":["../../../../../packages/router/src/router_outlet_context.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAmBA;;;;;AAAA;;sBAC8B,IAAI;qBACH,IAAI;wBACS,IAAI;wBACnC,IAAI,sBAAsB,EAAE;yBACH,IAAI;;wBAxB1C;IAyBC,CAAA;;;;;;AAND,yBAMC;;;;;;;;;;;;;;;;;;AAOD;;;;;AAAA;;wBAEqB,IAAI,GAAG,EAAyB;;IAEnD,6DAA6D;;;;;;;IAC7D,qDAAoB;;;;;;IAApB,UAAqB,SAAiB,EAAE,MAAoB;QAC1D,qBAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QACnD,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;QACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;KACvC;IAED;;;;OAIG;;;;;;;;IACH,uDAAsB;;;;;;;IAAtB,UAAuB,SAAiB;QACtC,qBAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC3C,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACZ,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;SACvB;KACF;IAED;;;OAGG;;;;;;IACH,oDAAmB;;;;;IAAnB;QACE,qBAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;QAC1B,MAAM,CAAC,QAAQ,CAAC;KACjB;;;;;IAED,mDAAkB;;;;IAAlB,UAAmB,QAAoC,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,EAAE;;;;;IAEtF,mDAAkB;;;;IAAlB,UAAmB,SAAiB;QAClC,qBAAI,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAEzC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACb,OAAO,GAAG,IAAI,aAAa,EAAE,CAAC;YAC9B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;SACvC;QAED,MAAM,CAAC,OAAO,CAAC;KAChB;;;;;IAED,2CAAU;;;;IAAV,UAAW,SAAiB,IAAwB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,EAAE;iCA9EpG;IA+EC,CAAA;;;;;;AA/CD,kCA+CC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentFactoryResolver, ComponentRef} from '@angular/core';\n\nimport {RouterOutlet} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\n\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n *\n */\nexport class OutletContext {\n  outlet: RouterOutlet|null = null;\n  route: ActivatedRoute|null = null;\n  resolver: ComponentFactoryResolver|null = null;\n  children = new ChildrenOutletContexts();\n  attachRef: ComponentRef<any>|null = null;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n *\n */\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutlet): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) { this.contexts = contexts; }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext();\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext|null { return this.contexts.get(childName) || null; }\n}\n"]}