/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/// <reference types="dom-view-transitions" />
import { DOCUMENT } from '@angular/common';
import { afterNextRender, AfterRenderPhase, InjectionToken, NgZone, runInInjectionContext, } from '@angular/core';
export const CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? 'view transition helper' : '');
export const VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? 'view transition options' : '');
/**
 * A helper function for using browser view transitions. This function skips the call to
 * `startViewTransition` if the browser does not support it.
 *
 * @returns A Promise that resolves when the view transition callback begins.
 */
export function createViewTransition(injector, from, to) {
    const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
    const document = injector.get(DOCUMENT);
    // Create promises outside the Angular zone to avoid causing extra change detections
    return injector.get(NgZone).runOutsideAngular(() => {
        if (!document.startViewTransition || transitionOptions.skipNextTransition) {
            transitionOptions.skipNextTransition = false;
            // The timing of `startViewTransition` is closer to a macrotask. It won't be called
            // until the current event loop exits so we use a promise resolved in a timeout instead
            // of Promise.resolve().
            return new Promise((resolve) => setTimeout(resolve));
        }
        let resolveViewTransitionStarted;
        const viewTransitionStarted = new Promise((resolve) => {
            resolveViewTransitionStarted = resolve;
        });
        const transition = document.startViewTransition(() => {
            resolveViewTransitionStarted();
            // We don't actually update dom within the transition callback. The resolving of the above
            // promise unblocks the Router navigation, which synchronously activates and deactivates
            // routes (the DOM update). This view transition waits for the next change detection to
            // complete (below), which includes the update phase of the routed components.
            return createRenderPromise(injector);
        });
        const { onViewTransitionCreated } = transitionOptions;
        if (onViewTransitionCreated) {
            runInInjectionContext(injector, () => onViewTransitionCreated({ transition, from, to }));
        }
        return viewTransitionStarted;
    });
}
/**
 * Creates a promise that resolves after next render.
 */
function createRenderPromise(injector) {
    return new Promise((resolve) => {
        // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).
        // This ensures any follow-up renders in the microtask queue are completed before the
        // view transition starts animating.
        afterNextRender(() => setTimeout(resolve), { injector, phase: AfterRenderPhase.Read });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlld190cmFuc2l0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvcm91dGVyL3NyYy91dGlscy92aWV3X3RyYW5zaXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsOENBQThDO0FBRTlDLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQ0wsZUFBZSxFQUNmLGdCQUFnQixFQUNoQixjQUFjLEVBRWQsTUFBTSxFQUNOLHFCQUFxQixHQUN0QixNQUFNLGVBQWUsQ0FBQztBQUl2QixNQUFNLENBQUMsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLGNBQWMsQ0FDdEQsU0FBUyxDQUFDLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUMxQyxDQUFDO0FBQ0YsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxjQUFjLENBRXZELFNBQVMsQ0FBQyxDQUFDLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBbUU5Qzs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsUUFBa0IsRUFDbEIsSUFBNEIsRUFDNUIsRUFBMEI7SUFFMUIsTUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDaEUsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QyxvRkFBb0Y7SUFDcEYsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtRQUNqRCxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixJQUFJLGlCQUFpQixDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDMUUsaUJBQWlCLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO1lBQzdDLG1GQUFtRjtZQUNuRix1RkFBdUY7WUFDdkYsd0JBQXdCO1lBQ3hCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFFRCxJQUFJLDRCQUF3QyxDQUFDO1FBQzdDLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMxRCw0QkFBNEIsR0FBRyxPQUFPLENBQUM7UUFDekMsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsbUJBQW1CLENBQUMsR0FBRyxFQUFFO1lBQ25ELDRCQUE0QixFQUFFLENBQUM7WUFDL0IsMEZBQTBGO1lBQzFGLHdGQUF3RjtZQUN4Rix1RkFBdUY7WUFDdkYsOEVBQThFO1lBQzlFLE9BQU8sbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLEVBQUMsdUJBQXVCLEVBQUMsR0FBRyxpQkFBaUIsQ0FBQztRQUNwRCxJQUFJLHVCQUF1QixFQUFFLENBQUM7WUFDNUIscUJBQXFCLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLHVCQUF1QixDQUFDLEVBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekYsQ0FBQztRQUNELE9BQU8scUJBQXFCLENBQUM7SUFDL0IsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLG1CQUFtQixDQUFDLFFBQWtCO0lBQzdDLE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRTtRQUNuQyxnR0FBZ0c7UUFDaEcscUZBQXFGO1FBQ3JGLG9DQUFvQztRQUNwQyxlQUFlLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO0lBQ3ZGLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cImRvbS12aWV3LXRyYW5zaXRpb25zXCIgLz5cblxuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIGFmdGVyTmV4dFJlbmRlcixcbiAgQWZ0ZXJSZW5kZXJQaGFzZSxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBOZ1pvbmUsXG4gIHJ1bkluSW5qZWN0aW9uQ29udGV4dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7QWN0aXZhdGVkUm91dGVTbmFwc2hvdH0gZnJvbSAnLi4vcm91dGVyX3N0YXRlJztcblxuZXhwb3J0IGNvbnN0IENSRUFURV9WSUVXX1RSQU5TSVRJT04gPSBuZXcgSW5qZWN0aW9uVG9rZW48dHlwZW9mIGNyZWF0ZVZpZXdUcmFuc2l0aW9uPihcbiAgbmdEZXZNb2RlID8gJ3ZpZXcgdHJhbnNpdGlvbiBoZWxwZXInIDogJycsXG4pO1xuZXhwb3J0IGNvbnN0IFZJRVdfVFJBTlNJVElPTl9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuPFxuICBWaWV3VHJhbnNpdGlvbnNGZWF0dXJlT3B0aW9ucyAmIHtza2lwTmV4dFRyYW5zaXRpb246IGJvb2xlYW59XG4+KG5nRGV2TW9kZSA/ICd2aWV3IHRyYW5zaXRpb24gb3B0aW9ucycgOiAnJyk7XG5cbi8qKlxuICogT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIFZpZXcgVHJhbnNpdGlvbnMgaW50ZWdyYXRpb24gaW4gdGhlIFJvdXRlci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAcHVibGljQXBpXG4gKiBAc2VlIHdpdGhWaWV3VHJhbnNpdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3VHJhbnNpdGlvbnNGZWF0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTa2lwcyB0aGUgdmVyeSBmaXJzdCBjYWxsIHRvIGBzdGFydFZpZXdUcmFuc2l0aW9uYC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkaXNhYmxpbmcgdGhlXG4gICAqIGFuaW1hdGlvbiBkdXJpbmcgdGhlIGFwcGxpY2F0aW9uJ3MgaW5pdGlhbCBsb2FkaW5nIHBoYXNlLlxuICAgKi9cbiAgc2tpcEluaXRpYWxUcmFuc2l0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIGBWaWV3VHJhbnNpdGlvbmAgaXMgY3JlYXRlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBydW4gaW4gYW4gaW5qZWN0aW9uIGNvbnRleHQgYW5kIGNhbiB1c2UgYGluamVjdGAuXG4gICAqL1xuICBvblZpZXdUcmFuc2l0aW9uQ3JlYXRlZD86ICh0cmFuc2l0aW9uSW5mbzogVmlld1RyYW5zaXRpb25JbmZvKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFRoZSBpbmZvcm1hdGlvbiBwYXNzZWQgdG8gdGhlIGBvblZpZXdUcmFuc2l0aW9uQ3JlYXRlZGAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gdGhlXG4gKiBgd2l0aFZpZXdUcmFuc2l0aW9uc2AgZmVhdHVyZSBvcHRpb25zLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3VHJhbnNpdGlvbkluZm8ge1xuICAvLyBUT0RPKGF0c2NvdHQpOiBUaGlzIHR5cGUgY2FuL3Nob3VsZCBiZSB0aGUgYnVpbHQtaW4gYFZpZXdUcmFuc2l0aW9uYCB0eXBlXG4gIC8vIGZyb20gQHR5cGVzL2RvbS12aWV3LXRyYW5zaXRpb25zIGJ1dCBleHBvcnRpbmcgdGhhdCB0eXBlIGZyb20gdGhlIHB1YmxpYyBBUEkgaXMgY3VycmVudGx5IG5vdFxuICAvLyBzdXBwb3J0ZWQgYnkgdG9vbGluZy5cbiAgLyoqXG4gICAqIFRoZSBgVmlld1RyYW5zaXRpb25gIHJldHVybmVkIGJ5IHRoZSBjYWxsIHRvIGBzdGFydFZpZXdUcmFuc2l0aW9uYC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVmlld1RyYW5zaXRpb25cbiAgICovXG4gIHRyYW5zaXRpb246IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WaWV3VHJhbnNpdGlvbi9maW5pc2hlZFxuICAgICAqL1xuICAgIGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZpZXdUcmFuc2l0aW9uL3JlYWR5XG4gICAgICovXG4gICAgcmVhZHk6IFByb21pc2U8dm9pZD47XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVmlld1RyYW5zaXRpb24vdXBkYXRlQ2FsbGJhY2tEb25lXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbGJhY2tEb25lOiBQcm9taXNlPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZpZXdUcmFuc2l0aW9uL3NraXBUcmFuc2l0aW9uXG4gICAgICovXG4gICAgc2tpcFRyYW5zaXRpb24oKTogdm9pZDtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBgQWN0aXZhdGVkUm91dGVTbmFwc2hvdGAgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyB0cmFuc2l0aW9uaW5nIGZyb20uXG4gICAqL1xuICBmcm9tOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90O1xuICAvKipcbiAgICogVGhlIGBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90YCB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHRyYW5zaXRpb25pbmcgdG8uXG4gICAqL1xuICB0bzogQWN0aXZhdGVkUm91dGVTbmFwc2hvdDtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgdXNpbmcgYnJvd3NlciB2aWV3IHRyYW5zaXRpb25zLiBUaGlzIGZ1bmN0aW9uIHNraXBzIHRoZSBjYWxsIHRvXG4gKiBgc3RhcnRWaWV3VHJhbnNpdGlvbmAgaWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAqXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB2aWV3IHRyYW5zaXRpb24gY2FsbGJhY2sgYmVnaW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlld1RyYW5zaXRpb24oXG4gIGluamVjdG9yOiBJbmplY3RvcixcbiAgZnJvbTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAgdG86IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgdHJhbnNpdGlvbk9wdGlvbnMgPSBpbmplY3Rvci5nZXQoVklFV19UUkFOU0lUSU9OX09QVElPTlMpO1xuICBjb25zdCBkb2N1bWVudCA9IGluamVjdG9yLmdldChET0NVTUVOVCk7XG4gIC8vIENyZWF0ZSBwcm9taXNlcyBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmUgdG8gYXZvaWQgY2F1c2luZyBleHRyYSBjaGFuZ2UgZGV0ZWN0aW9uc1xuICByZXR1cm4gaW5qZWN0b3IuZ2V0KE5nWm9uZSkucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiB8fCB0cmFuc2l0aW9uT3B0aW9ucy5za2lwTmV4dFRyYW5zaXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25PcHRpb25zLnNraXBOZXh0VHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgLy8gVGhlIHRpbWluZyBvZiBgc3RhcnRWaWV3VHJhbnNpdGlvbmAgaXMgY2xvc2VyIHRvIGEgbWFjcm90YXNrLiBJdCB3b24ndCBiZSBjYWxsZWRcbiAgICAgIC8vIHVudGlsIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AgZXhpdHMgc28gd2UgdXNlIGEgcHJvbWlzZSByZXNvbHZlZCBpbiBhIHRpbWVvdXQgaW5zdGVhZFxuICAgICAgLy8gb2YgUHJvbWlzZS5yZXNvbHZlKCkuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSkpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlVmlld1RyYW5zaXRpb25TdGFydGVkOiAoKSA9PiB2b2lkO1xuICAgIGNvbnN0IHZpZXdUcmFuc2l0aW9uU3RhcnRlZCA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlVmlld1RyYW5zaXRpb25TdGFydGVkID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICByZXNvbHZlVmlld1RyYW5zaXRpb25TdGFydGVkKCk7XG4gICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSB1cGRhdGUgZG9tIHdpdGhpbiB0aGUgdHJhbnNpdGlvbiBjYWxsYmFjay4gVGhlIHJlc29sdmluZyBvZiB0aGUgYWJvdmVcbiAgICAgIC8vIHByb21pc2UgdW5ibG9ja3MgdGhlIFJvdXRlciBuYXZpZ2F0aW9uLCB3aGljaCBzeW5jaHJvbm91c2x5IGFjdGl2YXRlcyBhbmQgZGVhY3RpdmF0ZXNcbiAgICAgIC8vIHJvdXRlcyAodGhlIERPTSB1cGRhdGUpLiBUaGlzIHZpZXcgdHJhbnNpdGlvbiB3YWl0cyBmb3IgdGhlIG5leHQgY2hhbmdlIGRldGVjdGlvbiB0b1xuICAgICAgLy8gY29tcGxldGUgKGJlbG93KSwgd2hpY2ggaW5jbHVkZXMgdGhlIHVwZGF0ZSBwaGFzZSBvZiB0aGUgcm91dGVkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gY3JlYXRlUmVuZGVyUHJvbWlzZShpbmplY3Rvcik7XG4gICAgfSk7XG4gICAgY29uc3Qge29uVmlld1RyYW5zaXRpb25DcmVhdGVkfSA9IHRyYW5zaXRpb25PcHRpb25zO1xuICAgIGlmIChvblZpZXdUcmFuc2l0aW9uQ3JlYXRlZCkge1xuICAgICAgcnVuSW5JbmplY3Rpb25Db250ZXh0KGluamVjdG9yLCAoKSA9PiBvblZpZXdUcmFuc2l0aW9uQ3JlYXRlZCh7dHJhbnNpdGlvbiwgZnJvbSwgdG99KSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHJhbnNpdGlvblN0YXJ0ZWQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgbmV4dCByZW5kZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclByb21pc2UoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIC8vIFdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gZW1wdHkgYWZ0ZXIgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMgKGJ5IHdhaXRpbmcgYSBtYWNyb3Rhc2spLlxuICAgIC8vIFRoaXMgZW5zdXJlcyBhbnkgZm9sbG93LXVwIHJlbmRlcnMgaW4gdGhlIG1pY3JvdGFzayBxdWV1ZSBhcmUgY29tcGxldGVkIGJlZm9yZSB0aGVcbiAgICAvLyB2aWV3IHRyYW5zaXRpb24gc3RhcnRzIGFuaW1hdGluZy5cbiAgICBhZnRlck5leHRSZW5kZXIoKCkgPT4gc2V0VGltZW91dChyZXNvbHZlKSwge2luamVjdG9yLCBwaGFzZTogQWZ0ZXJSZW5kZXJQaGFzZS5SZWFkfSk7XG4gIH0pO1xufVxuIl19